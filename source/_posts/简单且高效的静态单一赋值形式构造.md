---
title: 简单且高效的静态单一赋值形式构造
tags:
  - compiler
categories:
  - dissertation translation
  - compiler
date: 2022-04-30 17:23:43
mathjax: true
description:
---

**摘要** 我们提出一个简单的 SSA 构造算法，它允许直接从抽象语法树或者字节码翻译到一个基于 SSA 的中间表示形式。这个算法不需要事先的分析，且保证在中间表示构造期间是 SSA 的形式。这样允许在构造期间应用基于 SSA 的优化。在完成后，中间表示是最小且纯的 SSA 形式。尽管它很简单，我们算法的运行时间与 Cytron 等人的算法相当。

 <!-- more -->

## 简介

许多现代编译器具有的中间表示（IR）是基于静态单一赋值形式的（SSA 形式）。SSA 旨在通过紧凑地表示 use-def 链，来提高程序分析的效率。在过去的几年里，事实证明，SSA 形式不仅有助于提高分析效率，而且更有利于实现，测试和调试。因此，现代编译器如 Java HotSpot VM[14]，LLVM[2]，和 libFirm[1] 都是基于 SSA 形式的中间表示。

第一个高效构造 SSA 形式的算法是由 Cytron 等人[10] 提出的。这个算法仍然十分流行的一个原因是，它保证了放置$\phi$函数数量的最小形式。但是，对于需要完全基于 SSA 的编译器，这个算法有个显著的缺点：它的输入程序不得不表示为非-SSA 形式的控制流图（CFG）。因此，如果编译器想要从输入语言（给定的抽象语法树或一些字节码格式）构造 SSA 形式，它必须通过非SSA CFG 绕道，才能应用 Cytron等人 的算法。此外，为了保证最小的$\phi$函数放置，Cytron 等人的算法依赖于其它几个分析和转换：为了计算放置 $\phi$ 函数的位置，需要计算支配树和迭代支配边界。为了避免放置死 $\phi$ 函数，不得不执行活性分析或者死代码消除[7]。两个都需要 CFG 和依赖于其它分析，因而不便于在 SSA 为中心的编译器中使用这个算法。

现代基于 SSA 的编译器使用了不同的方法来构造 SSA：例如，LLVM 使用 Cytron 等人的算法，通过将所有局部变量放入内存（这通常不在 SSA 的形式中）中来模拟非-SSA 的 CFG。这些使用内存操作表达那些变量的简单定义和使用是由代价的。我们的测量表明 LLVM 前端生成的指令中有 25% 是这种类型：在 IR 构造之后立即被 SSA 构造移除。

其它编译器，如 Java HotSpot VM，因为上面提到的不便之处，完全不使用 Cytron 等人的算法。但是，它们也有问题，没有计算最小或者纯的 SSA 形式，也就是说，它们插入了多余的或者死的 $\phi$ 函数。

在这篇文章中，我们

- 提出了一个简单的，新的 SSA 构造算法，它既不需要支配也不用迭代支配边界。因此，它适用于直接从 AST 中构造一个基于 SSA 的中间表示（第 2 节）；
- 展示如何在IR构造期间，将这个算法和实时优化结合来降低占用空间（第 3.1 节）；
- 描述了一个后期过程，用于构造任意程序的最小 SSA 形式（第 3.2 节）；
- 证明了这个 SSA 构造算法可以构造所有程序的纯的 SSA 形式，和可以构造可规约控制流的程序的最小 SSA 形式（第 4 节）；
- 表明这个算法可以应用到其它相关的领域，如将一个命令式的程序转换为一个函数式连续传递格式（CPS）的程序，或者在转换后重构 SSA 形式，如生命周期范围拆分或者再具化，已经添加了更多的定义到一个 SSA 值上（第 5 节）；
- 证明算法的高效性和简易性。是通过再 Clang 中实现这个算法，然后和 Clang/LLVM 中的 Cytron 等人的算法实现进行比较来证明的。（第 6 节）。

据我们所知，本文提出的这个算法是第一个可以在可规约 CFG 上构建最小和纯 SSA 而不需要依赖于其它的分析。

## 简单的 SSA 构造

接下来，我们描述我们的算法来构造 SSA 形式。

