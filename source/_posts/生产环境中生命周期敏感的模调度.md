---
title: 生产环境中生命周期敏感的模调度
tags:
  - compiler
  - software pipeline
categories:
  - dissertation translation
  - compiler
date: 2023-01-02 20:19:45
mathjax: true
description:
---

## 摘要

这篇文章给出了一个新的软流水方法，称为摇摆模调度算法（SMS）。 它生成的调度在起始间隔，寄存器需求，和阶段数量方面都是几乎最优的。摇摆模调度算法是一个启发式方法，计算开销比较低。这篇文章首先描述了相关技术，然后在通用 VLIW 架构上的 Pefect Club 基准测试套上评估它。SMS 和其它的启发式方法相比，表明了它获得的调度质量和编译时间方面都优于其它的。为了进一步探索 SMS    的效果，描述了为 Equator MAP1000 处理器的生产质量编译器添加这个优化的一些经验；讨论了实现的问题，以及原始算法的修改和提高。最后，使用一组工业多媒体应用给出了一个实验结果。

 <!-- more -->

## 简介

软流水[5] 是一种利用循环外的指令级并行的技术，通过重复循环的连续迭代，然后并行地执行它们来实现的。关键的思路是寻找一个操作符的模式（称为核心代码），如此，当重复迭代这个模式的时候，它产生的效果是一个迭代会在上一个完成之前就启动好了。

激进的调度技术，如软流水等的缺点是高的寄存器压力。寄存器的需求会随着并行度的增加而增加[27]，[22]，因为机器要么有较深的流水线，要么有较宽的发射窗口，或者两者都有。寄存器，和功能单元一样，是有限的资源。因此，如果调度需要的寄存器比可用的更多，就不得不执行一些动作了，如添加溢出代码。溢出代码的添加会降低性能[22]，因为调度器额外的周期，或者因为内存内存干扰。

一些研究组已经将他们的目标放到寻找问题最佳解法的明确方法上了。例如，[16] 中的提案，搜索整个调度空间来寻找最小内存需求的资源限制下的约束，而 [2]，[7]，[13] 中的提案是寻找实际寄存器需求最小的调度。为循环生成一个最优（吞吐量和寄存器需求）的资源约束的调度的任务是一个已知的 NP 难的问题。所有这些已知的方法都需要一个令人望而却步的时间来构造调度，因此，它们的可用性只能被限制在很小的循环里。故而，实际的算法会使用一些启发式来引导调度的过程。文献中的一些提案只关心是否达成高吞吐量 [11]，[19]，[20]，[31]，[32]，[37]，而另一些提案的目标是最小化寄存器需求[9]，[12]，[18]，[24]，产生更高效的调度。

多级调度[12] 本身不是一个完全的模调度器，而是一组降低任意给定模调度的寄存器需求的启发式。它是通过在调度中移动操作达成目标的。生成的调度具有相同的吞吐量，但只需要更少的寄存器需求。不幸地是，在操作符移动中的限制可能会产生次优的寄存器需求降低。相似的启发式已经包含在 IRIS[9] 调度器里了，其是基于迭代模调度 [11]，[13] 的，为了在调度执行的同时降低寄存器压力。

松弛调度[18] 是一个将一些操作往后调度的同时将可以降低寄存器需求的操作往前调度的启发式技术，从而可以达成最大执行率。这个算法结合了复发约束和关键路径考量，从而可以判定每个操作的调度时机。这个算法某种意义上类似于迭代的模调度，它使用了有限的回溯，可能会将已经调度好的操作弹出，从而给新的留出位置。

超节点归约模调度（HRMS）[24]，[25] 是一个尝试缩短循环变量生命周期且不牺牲性能的启发式策略。HRMS 的主要贡献是节点排序策略。这个排序过程会在调度节点之前排序它们，从而每个节点要么它的前驱都在它调度之前被调度好，要么它的后继都在它调度之前被调度好（除了循环的）。在调度阶段，如果一个节点的前驱/后继已经调度了，则会尽可能地前面/后面地调度它。HRMS  与其它启发式方法 [18]，[37] 相比，在实现的吞吐量和编译时间上是由更好的性能的。HRMS 的主要缺点是调度启发式没有将节点的关键性纳入到考量中。

在这篇文章中，我们给出了一个新的调度策略，*摇摆模调度*（SMS），考虑了节点的关键性。它是一个低计算开销的启发式技术（如，编译 Prefect Club 所有最内层的不带条件退出和过程调用的循环的时间开销是少于半分钟的）。这篇文章也描述了它在一个具体的 VLIW 处理器的产品编译器中的实现，这个处理器的目标是数字消费者产品。性能图表明了生成在各种消费者工作负载上的调度效果。

本文剩余部分的组织如下：第 2 节给出了软流水的主要概念。第 3 节讨论了启发我们想法的一个例子，其在第 4 节中会被形式化。第 5 节给出了我们的 SMS 生成的调度的实验评估的主要结果。第 6 节会用于描述将 SMS 放入到产品编译器中的经验，以及它对一些真实工作负载的评估。主要的结论评价在第 7 节中给出。

## 软流水的概述

在软流水化的循环中，一个迭代的调度被分成了多个阶段，所以处于不同阶段的连续迭代的执行是可以重叠。一个迭代中的阶段数量被称为阶段数（SC）。软流水中的连续迭代起始之间的周期数量称为启动间隔（II）[32]。图 1 给出了一个简单的例子，由三个操作（V1，V2，和V3）组成的软流水的执行过程。在这个例子中，II = 4，SC = 3。

两个连续迭代的启动间隔 *II* 是由图中的重复循环（*RecMII*）和架构中的资源约束（*ResMII*）确定的。*II* 的下界称为最小的启动间隔（$MII = max(RecMII, ResMII)$）。读者可以参考扩展论文  [11]，[31] 来了解如何计算 *ResMII* 和 *RecMII*。

循环中使用的变量要么对应的是循环不变量，要么是循环变量。在循环执行期间，循环不变量是重复使用的，绝不会被定义。对于循环的所有迭代，每个循环不变量都只有一个值，因此不管是什么样的调度和机器配置，它都只需要一个寄存器。

对于循环变量，它的值会在每次循环迭代中都生成，因此，对于每次迭代都对应一个不同的生命周期。因为软流水的特性，一个迭代中定义的值的生命周期可以和下一个迭代中定义的值的生命周期重叠。这就是为什么寄存器需求会增加的主要原因。此外，对于生命周期大于 *II* 的值，新值在前一个值被使用前就生成了。为了修复这个问题，提出了软件解决方案（模变量展开[21]）和硬件解决方案（循环寄存器文件 [10]，[17]）。

一些软件流水方法都可以视为有两个两个连续的独立步骤：节点排序和节点调度。假设 *MII* 作为 *II* 的初始值，执行这两个步骤。如果根据这个 *II* 无法获得调度，则增加 *II* 然后在执行调度步骤。下一节会给出排序步骤是如何影响循环的寄存器需求的。

## 动机例子

考虑图 2 中的依赖图，以及具有相同图片中设定的流水线功能单元和延时的架构配置。因为图 2 中没有重用的循环，它的启动间隔只被有效的资源限制；在这个场景下，最可能被限制的资源是乘法器，它使得 $MII = 4/1 = 4$ 。

将操作排列成调度的一个可能的方法是使用自上而下的方法，它会优先处理关键路径上的操作；在这个排序的情况下，节点按如下顺序优先调度：<n1, n2, n5, n8, n9, n3, n10, n6, n4, n11, n12, n7>。图 3a 给出了一个迭代自顶向下的调度，图 3c 是核心代码（括号中的数字表示操作所属的阶段）。图 3b 给出了循环变量的声明周期。循环变量开始于生产者被发射，结束于最后一个消费者被发射。图 3d 给出了这个调度的寄存器需求；对于每个周期，它给出了调度的需要的存活变量。在任意周期中同时存在的存活变量的最大数量可以近似为所需的寄存器数量，它称为*MaxLive*（对于巨大数量的循环，[33] 表明寄存器分配需要的不会超过*MaxLive + 1*）。图 3d 中，$MaxLive = 11$。需要注意的是，在这个方法中，节点 *n2*  和 *n9* 有个没必要的巨长的生命周期，是由于调度中相关的操作被过早防止导致的；因此，循环的寄存器需求增加了。

在 HRMS [24] 中，排序的目标是所有的操作（除了第一个）都有前一个已调度完成的依赖操作。例如，对于前一个例子，它们建议的是如下的调度节点顺序<n1, n3, n5, n6, n4, n7, n8, n10, n11, n9, n2, n12>。注意到，对于这个调度顺序，在 n2 和 n9 需要在局部调度中放置时，它们都有一个依赖操作（分别是 n8 和 n10）已经放置好了。

图 4a 给出了每遍迭代最后的调度。例如，当操作 n9 被调度时，则操作 n10 已经在调度中放置好了（在第 8 个周期），所以它会尽可能第被调度得靠近它（在第 6 个周期），因此降低了 n9 生成的值的生命周期。类似的情况也发生在操作 n2 上了，在它的后继被调度的时候，它也已经被放在了调度中了。图 4b 给出了循环变量的生命周期，图 4d 给出了调度的寄存器需求。在这个场景中，*MaxLive = 9*。

HRMS 建议的顺序没有提高关键路径上的优先权。例如，操作 n5 需要在操作 n1 初始化之后两个周期调度；但是，它却没有，因为在这个周期中，地址器正在繁忙地执行操作 n3，因为它在之前已经被调度了。因为这个，一个在更关键路径（n5）上的操作被前一个在不太关键的路径（n3）上的操作给延迟了。操作 n11 也发生了类似的事情，它与属于非关键路径的操作 n6 的位置冲突了，但是在选择它之前顺序已经确定了。图 5a 和图 5c 给出了我们的想法获得的调度，图 5b 和图 5d 给出了变量的生命周期和寄存器的需求量。这个调度的 *MaxLive* 是 8。这个调度是使用如下顺序<n12, n11, n10, n8, n5, n6, n1, n2, n9, n3, n4, n7>获得的。需要注意的是，关键路径上的节点，相比其它节点，是具有一定的调度优先级的。下一节详细的介绍了基于这些想法和调度步骤排序节点的算法。

## 摇摆模调度（SMS）

大部分模调度方法由两步组成。首先，它们计算一个尝试缩小 *II* 的调度，但不关心寄存器压力，然后将变量分配到寄存器上。软流水循环的执行时间依赖于 *II*，存活变量的最大数量（*MaxLive*）和阶段数量。*II* 决定了循环迭代的发射率。对于第二个因素，如果 *MaxLive* 不高于可用的寄存器数量，则计算好的调度是有效的，它不会影响到执行时间。否则，需要采取一些动作来降低寄存器压力。[33] 概述了一些可能的方法，并在 [22] 中给出了效果评估：

- 根据增加后的 *II* 重新调度循环。通常，增加 *II* 将会降低 *MaxLive*，但它会降低发射率。
- 添加溢出代码。这个也由副作用，因为它会增加所需的内存带宽，然后导致更多的内存惩罚（如，缓存未命中）。此外，内存会变成最长利用的资源，因此，添加溢出代码将会需要增加 *II*。

最后，阶段数量决定了循环结尾部分的迭代数量（它完全等于阶段数量减去一）。

*摇摆模调度* 是一种尝试达成最小化 *II*，降低 *MaxLive*，和最小化阶段数量的模调度算法。它是一种有着比较低计算开销的同时，产生的调度非常接近于由基于极致搜索的最优方法产生的调度的启发式技术，最优方法对于真实程序会有过高的计算成本。为了有较低的计算成本，SMS 只调度每个节点一次（不想其它基于回溯的方法[9], [11], [18], [31]）。尽管没有使用回溯，SMS 也产生了高效的调度，因为是在预调度顺序上调度的，这保证了 4.2 节中描述的某些属性。

为了取得最小的*II* ，以及降低阶段数量，SMS 按照一定的顺序调度节点，这个顺序考虑了每个节点所属的循环的 *RecMII*，其次也考虑了节点所属路径的关键级别。

为了降低 *MaxLive*，SMS 尝试最小化所有循环的值的生命周期。为了达成这个目的，它尝试让每个操作都尽可能地靠近它的前驱和后继。  当一个操作已经被调度了，如果这个局部的调度有唯一的前驱，则它会尽可能快地被调度。如果这个局部调度只包含后继，则它会被尽可能地往后调度。在被调度的操作同时包含前驱和后继的局部调度的场景中，获得的调度可能是不如预期的，因为在这个场景中，如果从前驱到操作的生命周期已经最小化了，则从操作到它的后继的生命周期就会增加。这种情况只发生在每个递归的一个节点上，如果循环不包含任意的递归，则它可以完全避免掉。

SMS 的算法由如下三个步骤组成，后面会进行详细地描述：

- 依赖图的计算和分析，
- 节点排序。
- 调度。

SMS 可以应用来为没有子程序调度的最内层循环生成代码。包含条件语句（IF）的循环可以在应用*if-转换* [1] 之后进行处理，要么是处理器支持预测执行[10]，要么是根据流水线翻转 *if-转换* [38]。

### 依赖图的计算和分析

最内侧循环的依赖图由一个四元素组（$DG = {V, E, \alpha, \lammda}$）组成：

- V 是图的节点（顶点）集合，其中，每个节点 $v \in V$ 对应循环的一个操作。
- E 是边的集合，其中每条边 $(u, v) \in E$ 表示从操作 u 到操作 v 的一个依赖。







