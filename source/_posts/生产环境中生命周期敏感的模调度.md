---
title: 生产环境中生命周期敏感的模调度
tags:
  - compiler
  - software pipeline
categories:
  - dissertation translation
  - compiler
date: 2023-01-02 20:19:45
mathjax: true
description:
---

## 摘要

这篇文章给出了一个新的软流水方法，称为摇摆模调度算法（SMS）。 它生成的调度在起始间隔，寄存器需求，和阶段数量方面都是几乎最优的。摇摆模调度算法是一个启发式方法，计算开销比较低。这篇文章首先描述了相关技术，然后在通用 VLIW 架构上的 Pefect Club 基准测试套上评估它。SMS 和其它的启发式方法相比，表明了它获得的调度质量和编译时间方面都优于其它的。为了进一步探索 SMS    的效果，描述了为 Equator MAP1000 处理器的生产质量编译器添加这个优化的一些经验；讨论了实现的问题，以及原始算法的修改和提高。最后，使用一组工业多媒体应用给出了一个实验结果。

 <!-- more -->

## 简介

软流水[5] 是一种利用循环外的指令级并行的技术，通过重复循环的连续迭代，然后并行地执行它们来实现的。关键的思路是寻找一个操作符的模式（称为核心代码），如此，当重复迭代这个模式的时候，它产生的效果是一个迭代会在上一个完成之前就启动好了。

激进的调度技术，如软流水等的缺点是高的寄存器压力。寄存器的需求会随着并行度的增加而增加[27]，[22]，因为机器要么有较深的流水线，要么有较宽的发射窗口，或者两者都有。寄存器，和功能单元一样，是有限的资源。因此，如果调度需要的寄存器比可用的更多，就不得不执行一些动作了，如添加溢出代码。溢出代码的添加会降低性能[22]，因为调度器额外的周期，或者因为内存内存干扰。

一些研究组已经将他们的目标放到寻找问题最佳解法的明确方法上了。例如，[16] 中的提案，搜索整个调度空间来寻找最小内存需求的资源限制下的约束，而 [2]，[7]，[13] 中的提案是寻找实际寄存器需求最小的调度。为循环生成一个最优（吞吐量和寄存器需求）的资源约束的调度的任务是一个已知的 NP 难的问题。所有这些已知的方法都需要一个令人望而却步的时间来构造调度，因此，它们的可用性只能被限制在很小的循环里。故而，实际的算法会使用一些启发式来引导调度的过程。文献中的一些提案只关心是否达成高吞吐量 [11]，[19]，[20]，[31]，[32]，[37]，而另一些提案的目标是最小化寄存器需求[9]，[12]，[18]，[24]，产生更高效的调度。

多级调度[12] 本身不是一个完全的模调度器，而是一组降低任意给定模调度的寄存器需求的启发式。它是通过在调度中移动操作达成目标的。生成的调度具有相同的吞吐量，但只需要更少的寄存器需求。不幸地是，在操作符移动中的限制可能会产生次优的寄存器需求降低。相似的启发式已经包含在 IRIS[9] 调度器里了，其是基于迭代模调度 [11]，[13] 的，为了在调度执行的同时降低寄存器压力。

松弛调度[18] 是一个将一些操作往后调度的同时将可以降低寄存器需求的操作往前调度的启发式技术，从而可以达成最大执行率。这个算法结合了复发约束和关键路径考量，从而可以判定每个操作的调度时机。这个算法某种意义上类似于迭代的模调度，它使用了有限的回溯，可能会将已经调度好的操作弹出，从而给新的留出位置。

超节点归约模调度（HRMS）[24]，[25] 是一个尝试缩短循环变量生命周期且不牺牲性能的启发式策略。HRMS 的主要贡献是节点排序策略。这个排序过程会在调度节点之前排序它们，从而每个节点要么它的前驱都在它调度之前被调度好，要么它的后继都在它调度之前被调度好（除了循环的）。在调度阶段，如果一个节点的前驱/后继已经调度了，则会尽可能地前面/后面地调度它。HRMS  与其它启发式方法 [18]，[37] 相比，在实现的吞吐量和编译时间上是由更好的性能的。HRMS 的主要缺点是调度启发式没有将节点的关键性纳入到考量中。

在这篇文章中，我们给出了一个新的调度策略，*摇摆模调度*（SMS），考虑了节点的关键性。它是一个低计算开销的启发式技术（如，编译 Prefect Club 所有最内层的不带条件退出和过程调用的循环的时间开销是少于半分钟的）。这篇文章也描述了它在一个具体的 VLIW 处理器的产品编译器中的实现，这个处理器的目标是数字消费者产品。性能图表明了生成在各种消费者工作负载上的调度效果。

本文剩余部分的组织如下：第 2 节给出了软流水的主要概念。第 3 节讨论了启发我们想法的一个例子，其在第 4 节中会被形式化。第 5 节给出了我们的 SMS 生成的调度的实验评估的主要结果。第 6 节会用于描述将 SMS 放入到产品编译器中的经验，以及它对一些真实工作负载的评估。主要的结论评价在第 7 节中给出。

## 软流水的概述

在软流水化的循环中，一个迭代的调度被分成了多个阶段，所以处于不同阶段的连续迭代的执行是可以重叠。一个迭代中的阶段数量被称为阶段数（SC）。软流水中的连续迭代起始之间的周期数量称为启动间隔（II）[32]。图 1 给出了一个简单的例子，由三个操作（V1，V2，和V3）组成的软流水的执行过程。在这个例子中，II = 4，SC = 3。

两个连续迭代的启动间隔 *II* 是由图中的重复循环（*RecMII*）和架构中的资源约束（*ResMII*）确定的。*II* 的下界称为最小的启动间隔（$MII = max(RecMII, ResMII)$）。读者可以参考扩展论文  [11]，[31] 来了解如何计算 *ResMII* 和 *RecMII*。

循环中使用的变量要么对应的是循环不变量，要么是循环变量。在循环执行期间，循环不变量是重复使用的，绝不会被定义。对于循环的所有迭代，每个循环不变量都只有一个值，因此不管是什么样的调度和机器配置，它都只需要一个寄存器。

对于循环变量，它的值会在每次循环迭代中都生成，因此，对于每次迭代都对应一个不同的生命周期。因为软流水的特性，一个迭代中定义的值的生命周期可以和下一个迭代中定义的值的生命周期重叠。这就是为什么寄存器需求会增加的主要原因。此外，对于生命周期大于 *II* 的值，新值在前一个值被使用前就生成了。为了修复这个问题，提出了软件解决方案（模变量展开[21]）和硬件解决方案（循环寄存器文件 [10]，[17]）。

一些软件流水方法都可以视为有两个两个连续的独立步骤：节点排序和节点调度。假设 *MII* 作为 *II* 的初始值，执行这两个步骤。如果根据这个 *II* 无法获得调度，则增加 *II* 然后在执行调度步骤。下一节会给出排序步骤是如何影响循环的寄存器需求的。

## 动机例子



