---
title: 一种高效计算单一静态赋值形式的方法
tags:
  - compiler
categories:
  - dissertation translation
  - compiler
date: 2022-04-14 12:04:46
description:
---

## 简介

在优化编译器中，数据结构的选择直接影响了实际程序优化的能力和效率。一个糟糕的数据结构选择会禁掉一些优化或者使得编译变慢，则高级优化特性会变得不受欢迎的。最近，静态单一赋值形式 [AWZ88，RWZ88] 和控制依赖图 [FOW87] 被提出用于表示程序的数据流和控制流属性。这些之前不相关的技术每个都为一类有用的程序优化提供了效率和功能。虽然这些结构都很吸引人，但它们的构建难度和它们的潜在大小阻挡了它们的使用[AJ88]。我们提出一种新的算法可以从任意的控制流图中高效计算出这些数据结构。我们给出了分析和实验证明，复杂度与远程程序大小成线性关系。因此，本文强有力的证明了这些数据结构可以实际应用到优化中。

在程序已经转为静态单一赋值形式后，有两个有用的属性：

1. 一个变量的每个程序员指定变量都会到达该变量的唯一赋值。
2. 第二节描述的该程序包含的 phi 函数，是用于区分沿着不同传入控制流边传入的变量值。

 <!-- more -->

SSA 形式的前身是通过在程序合适的位置往变量本身插入赋值获得属性 1 的。通过插入显式的 phi 函数，SSA 形式形成了比基于前身的工作方式更简单的工作方式[CLZ86，WZ85]。

属性1 已经被常量折叠算法使用了，它在编译时删除被证明不在使用的代码分支[WZ88]。缺少 SSA 形式时，数据流信息可能不得不在每次代码分支被删除时重新计算，使得算法成本过高。静态单一赋值形式很好的总结了代码移动相关的一些条件[CLZ86，RWZ88]。此外，通过 SSA 形式，简单数据流信息（定点-使用链）的表示更加紧凑。如果一个变量有 D 个定义和 U 个使用，则它们可以有 D*U 个定点-使用链。当类似的信息以 SSA 形式编码时，最多只有 E 个定义-使用链，E 是控制流图边的数量[RL86]。

对属性 2 的开发引出了全局值编号算法，它可以跨控制流追踪冗余计算[RWZ88]；和一个检测程序等价的算法[AWZ88]。这边还有一个通过重命名转化增加程序并行度的算法 [CF87b] ，它很像 SSA 的形式。

控制依赖 [FOW87，CF87a] 识别那些影响语句执行的条件。非正式的说，当一个跳转的一条边会导致语句实际上执行，而另一条边会导致语句跳过，则这个语句依赖于这个跳转。这样的信息对于检查并行、程序优化和额外的程序分析[HPR88] 是十分重要的 [ABC88]，

第二节解释了 SSA 形式。第三节引入一个新的结构叫做*支配边界*。然后，我们展示如何使用支配边界高效地计算 SSA 形式（第四节）和控制依赖图（第五节）。第六节展现了我们的算法行为在一些严格限制某些控制结构的程序里与程序大小成线性关系的。我们也通过报告 FORTRAN 程序的实验给出了大部分线性的证明。

{% if 1 == 1 %} 
  {% asset_img figure_1.png title %}
{% else %}
  ![](H:\Blogs\fiking\source\_posts\一种高效计算单一静态赋值形式的方法\figure_1.png)

{% endif %}

## 静态单一赋值形式

本文介绍的算法适用于含有任意控制结构的程序。在这样的程序中语句被限制为条件表达式和赋值语句。只考虑简单、无别名的变量；没有考虑数组或者指针值。对齐在 [WZ88] 中的技术容下了。

将一个程序转为静态单赋值（SSA）形式分为两步。第一步，特殊的赋值语句 phi 函数插入程序的某些点上。第二步，每个变量 V 用不同的整数 i 赋予几个新的名字 Vi。程序中每个提到的 V 都被替换为提到的新的名字之一 Vi。一个简单程序的 SSA 的形式如图 1 所示。

在详细解释 SSA 形式前，我们用有向图回顾了程序控制流的建模。程序的语句被组织为（不必要最大化）基本块，它表示程序流从第一条语句进入基本块，然后从最后一条语句离开基本块。图 1 中的基本块由括号中的数字列表示。控制流图或者 CFG 是有向无环图。CFG 的节点是程序的基本块和两个额外的节点：入口和出口。从入口有边能到任意程序可以进入的基本块。任意可以推出程序的基本块都有边到达出口。CFG 其它的边表示基础块间的控制转移（跳转）。我们假设每个节点都在从入口开始的路径上，也在每个去出口的路径上。

对于每个节点 X，X 的后继是指 CFG 中有一条 X->Y 的边，然后 *Succ(X)* 表示的是 X 的所有后继的集合（前驱也是类似的）。我们例子程序的控制流图在图 1 中的右边给出了。由于与控制依赖表示相关的技术原因，图中有从入口到出口的边。最后，每个变量被默认为在入口时有个赋值，表示在程序进入时变量可能具有任意值。这个赋值被视为与代码中显式出现的赋值一样。

一个 phi 函数有公式 U <- phi(V, W, ...），其中，U，V，W，... 是变量，V，W，... 等操作数的数量是 phi 函数存在点的控制流前驱的个数。程序中每个点的控制流前驱是以任意固定顺序排列的，且 phi 函数中的第 j 个操作数关联第 j 个前驱，如果控制从第 j 个前驱到达 phi 函数，则 U 被赋予第 j 个操作数的值。phi 函数的每次执行只会使用其中一个操作数，至于使用哪个取决于 phi 函数前的控制流。

对于任意的变量 V，可以在程序的任意 CFG 节点入口插入一个简单的 phi 函数 V <- phi(V, V, ...)，不会改变语义。为什么我们要执行这样的插入？通过小心放置插入的位置，然后重命名 V 的子项，我们可以将程序转为 SSA 的形式。具体来说，我们假定任意数量的新变量 Vi（i = 0，1，2，...）都可以生成做为 V 的新名字。如果转换后的程序被定义为 SSA 的形式，对于每个原始变量 V，V 的 phi 函数已经插入，然后 V 的每个使用都被改成了一个新名字 Vi 的使用，使得如下条件成立：

1. 如果一个 CFG 节点 Z 是两个非空路径 X->Z 和 Y->Z 共有的第一个节点，在 X 节点和 Y 节点的开头都包含 V 的赋值，则 V 的一个 phi 函数被插入到 Z 的开头。
2. V 的每个新名字 Vi 是程序代码中一个确定赋值语句的赋值目标。
3. 沿着每个控制流路径，考虑每个 V 使用新的名字 Vi （在转换后的程序中）和 V 的相应使用（在原始程序中）。然后 V 和 Vi 有相同的值。

当一个程序是 SSA 形式且插入的 phi 函数的数量尽可能的小，则它是最小 SSA 形式。

依赖于 SSA 形式的优化在有无关 phi 函数存在时，仍然是有效的， 除了那些需要最小 SSA 形式的。无关 phi 函数有些时候会通过隐瞒一些有用事实禁止优化；无关 phi 函数总是加入了一些不必要的固有开销到优化本身。因此，只放置需要的phi 节点是重要的。

对于任意的变量 V，源程序中我们需要插入 phi 函数的 CFG 节点可以通过 SSA 形式定义中的第一个条件递归定义。当那些两个路径源自不同的节点，包含 V 的赋值或者需要 V 的phi 函数，如果节点 Z 是两个非空控制流路径的共有节点，则 Z 需要一个 V 的 phi 函数。非递归地，我们可能或观察到一个节点 Z 需要 V 的 phi 函数，因为 Z 是从带有 V 赋值的节点 X 和 节点 Y 开始的两个非空路径 X->Z 和 Y->Z 的第一个共有节点。如果 Z 不是包含了已经包含了一个到 V 的赋值，则在 Z 插入 phi 函数，然后将 Z 加入到 V 的赋值节点集合里。当有更多的节点被认为是路径源时，我们可能会观察到更多的节点作为两个非空路径的第一个节点，节点开头有 V 的赋值。观察到需要 phi 函数的节点集合会一直增加直到它稳定。当 phi 函数以这样的方式放置时，可以通过一个简单自适应的大家熟知的 def-use 链来获得一个最小的 SSA 形式。本文提出的算法与暴力方式得到的结果相同，但放置 phi 函数和进行重命名的时间远小于暴力需要的时间。

最小化 SSA 形式是 Shapiro 和 Saint [SS70] 伪赋值概念的一种改进。V 的伪赋值节点就是那些需要 V phi 函数的节点。对于一个有 E 条边的 CFG ，其描述了一个调用 V 变量的程序，一个算法 [RT82] 需要 O（Ea（E））个位向量操作（每个向量长度为 V）来找到所有的伪赋值。对于可约束程序计算 SSA 形式的更简单算法需要 O（E x V）的时间。这些算法都是二次的，且 [RWZ88] 算法会使用一些无关的 phi 函数。这边提到的方法是 O（E+T+DF）的，其中 T 是普通的赋值和  phi 函数的总数，DF 是所有支配边界的总大小（我们后面会描述这个结构）。虽然数量 T 和 DT 可能是程序大小的二次方，但我们提供证据证明它们很少如此。这个见解允许我们得到一个不会随变量数量乘法增长的边界，其是一个我们可以根据支配边界决定哪边可以插入 phi 函数的时间边界。支配边界的大小只依赖于程序的控制流。

## 支配边界

这节中我们引入支配边界映射，然后给出一个计算它的算法。然后，我们将 phi 函数的正确位置和支配边界关联起来。

在进行前，我们回顾下控制流中节点间的支配关系。令 X 和 Y 为 CFG 中的节点。如果 X 出现在所有到达 Y 的路径上，则 X 支配 Y。支配既是自反的又是传递的。如果 X 支配 Y 且 $X \not= Y$ ，则 X 严格支配 Y。公式上，严格支配我们写为 $X \gg Y$ ，支配写为 $X\ge\ge Y$ 。为了说 X 没有严格支配 Y，我们写作 $X\not\gg Y$ 。Y的立即支配（表示为 idom（Y））是从 Entry 到 Y 的任意路径上 Y 最接近的严格支配者。在一个支配树上，节点 X 的子节点都是被 X 立即支配的。设 E 是 CFG 中边的数量。CFG 的支配树可以在 $ O(E\alpha(E))$ 时间里构建 [LT79]，或者（用更复杂的算法）在 $O(E)$ 时间里构建[Har85]。

CFG 的支配树有和 CFG 完全相同的节点集，但边集完全不同。这边的前驱，后继，和路径总是和 CFG 相关的。而父节点，子节点，祖先节点，和后裔节点总是和支配树相关的。

### 定义和算法

一个 CFG 节点 X 的支配边界 $DF(X)$ 是所有满足条件的 CFG 节点 Y，对应的条件是 X 支配 Y 的前驱，但不是严格支配 Y 的：
$$
DF(X) = {Y | (\exists P \in Pred(Y))(X\geq\geq P 且 X \not\gg Y)}.
$$
直接根据定义计算 $DF(X)$ 需要搜索支配树的大部分。所有节点 X 计算 $DF(X)$ 总时间将会是二次方的，即使计算集合很小。为了在支配边界映射大小相关的线性时间里计算支配边界映射，我们为每个节点定义了两个中间集 $DF_local$ 和 $DF_up $  ，然后保持下面的方程：
$$
DF(X) = DF_local(X)\cup  \bigcup_{Z\in Children(X)} DF_{up}(Z).     (1)
$$
对于任意节点 X，X 的一些后继会有助于 $DF(X)$。局部贡献 $DF_{local}(X)$ 按如下定义
$$
DF_{local}(X) = {Y\in Succ(X) | X \not\gg Y}.
$$
给定任意的节点 Z，它不是支配树的根入口，对于 $ X = idom(Z)$，$DF(Z)$ 中的一些节点会贡献给 $DF(X)$。贡献 $DF_{up}(Z)$ ，Z 传给 $idom(Z)$ 按如下定义：
$$
DF_{up}(Z) = {Y\in DF(Z) | idom(Z) \not\gg Y}.
$$
**引理 1** *支配边界公式（1）是正确的。*

*证明*  因为支配总是反身的，$DF_{local}(X) \subseteq DF(X)$。因为支配是及物的，X 的每个子节点 Z 有 $DF_{up}(Z) \subseteq DF(X)$。我们仍然必须证明 $DF(X)$ 中的所有东西都已经计算在内了。假设 $Y \in DF(X)$，然后令 $U\to Y$ 是一个 X 支配 U 但不严格支配 Y的边。如果 $ U = X$，然后 $ Y \in DF_{local}(X)$ 证明结束。如果 $U \neq X$，换句话说 X 的子节点 Z 支配 U 但不严格支配 Y，因为 X 不严格支配 Y。这隐含着 $Y\in DF_{up}(Z)$。

中间集可以用如下简单的相等测试计算。

**引理 2** 对于任意的节点 X，
$$
DF_{local}(X) = {Y \in Succ(X) | idom(Y) \neq X }.
$$
*证明* 我们假设 $Y\in Succ(X)$ 然后有：
$$
(X \gg Y) \Longleftrightarrow (idom(Y) = X).
$$
"if" 的部分是真的，因为严格支配是立即支配的传递闭包。对于 “only if” 的部分，假设 X 严格支配 Y，因此 X 的一些子节点 V 支配 Y。然后 V 出现在任意从入口到 Y 的路径上，到达 X，然后有边 $ X\rightarrow Y$，则有 V 支配 X，或 $ V = Y$。但是 V 不支配 X，所以 $V = Y$ 和 $ idom(Y) = idom(V) = X$。

**引理 3** 对于支配树里的任意的节点 X 和 X 的任意子节点 Z，
$$
DF_{up}(Z) = {Y\in DF(Z) | idom(Y) \not\gg X}.
$$
*证明* 我们假设 $Y\in DF(Z)$ 有如下			
$$
(X \gg Y) \Longleftrightarrow (idom(Y) = X).
$$
"if" 的部分是真的，因为严格支配是立即支配的传递闭包。对于 “only if” 的部分，假设 X 严格支配 Y，因此 X 的一些子节点 V 支配 Y。选择一个 Y 的前驱 U，Z 支配 U。然后 V 出现在任意从入口到 Y 的路径上，到达 U，然后有边 $ U\rightarrow Y$，则有 V 支配 X，或 $ V = Y$。如果$ V = Y$，则  $ idom(Y) = idom(V) = X$，然后证明结束。我们假设 $V \neq Y$（因此 V 支配 U）则有个矛盾。只有一个 X 的子节点可以支配 U，所以 $V = Z$ 且 Z 支配 Y。这与 $Y\in DF(Z)$ 的假设相矛盾。

这些结果暗示了图 2 中的计算支配边界的算法是正确的。/\*local\*/ 所在行高效的实时地计算了$DF_{local}(X)$ 然后在（1）中使用它，不需要额外的存储它。/\*up\*/ 对于 $DF_{up}(Z)$ 是相似的。我们自底向上遍历支配树，在访问完 X 的所有子节点后访问 X。为了说明这个算法的工作过程，我们在 图 3 中列出结果，其中的 CFG 是来自 图 1 中的程序。

{% if 1 == 1 %} 
  {% asset_img figure_2.png title %}
{% else %}
  ![](H:\Blogs\fiking\source\_posts\一种高效计算单一静态赋值形式的方法\figure_2.png)

{% endif %}

**定理 1** 图 2 中的算法是正确的。

*证明* 由前面的定理得到。

考虑一个有 N 个节点和 E 条边的 CFG。支配边界算法在计算$DF_{local}$时，最终会检查所有的 CFG 边。计算 $DF_{up}$ （最糟糕的时候）需要在支配树间传播 N 个节点。计算 $DF_{up}$ 以及 DF 需要的时间是和 $DF_{up}$ 成比例的。因为支配树有 $N-1$ 条边，计算用时$O(N^2)$。因此，整个算法的最坏复杂度是$O(E+N^2)$。但是，第六节表明通常 DF 映射大小通常是线性的。我们实现了这个算法，观察到它比 PTRAN 编译器里计算标准数据流要快[ABC88]。

{% if 1 == 1 %} 
  {% asset_img figure_3.png title %}
{% else %}
  ![](H:\Blogs\fiking\source\_posts\一种高效计算单一静态赋值形式的方法\figure_3.png)

{% endif %}

### 使用支配边界找需要的 $\phi$ 函数

我们从更正式地重述 $\phi$ 函数插入位置的非递归特性开始。对于 CFG 节点的一个集合 S，连接节点集合 $J(S)$ 被定义为所有 Z 节点的集合，Z 是两个开始与 S 中两个清楚节点的非空 CFG 路径的第一个公共节点。迭代添加$J(S)$ 是节点递增序列的极限：
$$
J_1 = J(S); 
$$

$$
J_{i+1} = J(S\cup J_i)
$$



