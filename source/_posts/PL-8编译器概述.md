---
title: PL_8编译器概述
tags:
  - compiler
categories:
  - dissertation translation
  - compiler
date: 2024-10-10 00:15:22
mathjax: true
description:
---

## 摘要

PL.8编译器接受多种源语言，并为几个不同机器生成高质量目标代码。使用的策略是先将源程序简单地转换成低级别中间语言。然后通过全局优化和寄存器分配来提高代码质量，而不是依赖于特殊代码选择。

 <!-- more -->

## 简介

PL.8是作为计算机架构，系统设计，编程语言和编译器技术之间交互的探索而开发的。目前它支持两种源语言，Pascal和PL.8，PL/I的一种进行系统编程的变种。为System/370，MC68000，801（10）和其它两种实验机器产生目标代码。编译器的作用是以不需要关注详细的性能问题的同时还能提供非常好的代码的方式支持高级语言编程。早期以这种方式使用优化编译器的经验是令人沮丧的。程序员因为性能原因不得不避免使用特定语言或方式。并且，需要覆盖更多好代码的场景的需求会导致编译器一直增长，直到它的体积，执行开销，或稳定性不够限制了进一步增长为止。为了避免这个复杂性，以及可以无成本地为语言和它的编译器添加许多新的特性，PL.8采用了将编译分解为一系列更简单和独立的问题的策略。

PL.8编译器有四个主要的组件。它们是：

转换 -- 源语言到中间语言（IL）的转换。中间语言可以被认为是一个简单抽象机器的指令集。

优化 -- 将中间语言转换为一个优化了运行时间或体积的等价程序。

寄存器分配 -- 把程序的寄存器空间归约到机器以及特定寄存器的分配。

末端汇编 -- 实际目标机器指令的选择，以及格式化编译器输出。

编译器进一步尽将优化划分为尽可能多的独立操作，使得它们更可靠和更容易实现。这种方法使得编译器能够可靠地生成目标代码，该代码通常优于以前的技术。（7）

在接下来的内容里，我们会描述PL.8编译器的整体结构，着重点是分离方案。我们也会描述使得这个方法可用所需的一些优化和寄存器分配技术，并且通过一个扩展例子，尝试提供一些这个技术为什么可以工作的一些见解。附录声明了使用的算法的一些更细节的报告。（3，4，5，6，8，9）

## 中间语言

IL可以被认为是一个简单抽象计算机的汇编语言。它的语义非常匹配目标机器的计算语义。它的整数运算是32位二进制补码，存储是32位地址空间里的字节地址。IL是以原始操作的线性字符串表示和处理的。这个代码可以被优化。为了最大的效果，它需要暴露所有可以在目标机器上执行的指令。因此，IL模式会比一些目标CPU更低级别。所有的计算都是在寄存器里完成的。即使没有存储到寄存器的加法或者类似的指令，代码也会被生成。因此源码语句：

```
x = y + z;
```

会产生如下结果：

```
L    RY, Y
L    RZ, Z
A    R100, RY, RZ
ST   R100, X
```

这样写的好处是任何或所有指令都可以通用化或者代码移动。例如，y的加载可以被移除到循环外，同时z的加载可以被循环里的另一个z的加载消除掉。（IL的一个简单描述参见附录。）

因为IL是低级别的，所以它比许多计算机更通用。例如，没有破坏指令。即使编译到System/370或者MC68000，这两个平台的Add的一个操作数会被破坏掉，Add也有两个操作数和一个结果操作数。另一方面，目标CPU会以微妙的方式显示出来。在MC68000范围是-32K到+32K，而在System/370是0到4K。这是非常需要暴露的，算术需要处理这些限制才能优化。因此，在MC68000上从位置5000加载一个变量只需要一条加载指令，而System/370需要：

```
AI  R100, R.X, 4096   Base of x + 4k
L   RX, X-4096(R100)  Load x
```

需要注意的是，IL体现了目标机器的某些特征，但不会影响到优化。我们在一个部分机器相关的IL上做机器无关的优化。

从某种意义上讲，IL像一个不存在的机器。它有无限多的符号寄存器。根据惯例，待有相同操作数的指令总是在相同符号寄存器里产生它们的结果。这有助于找到相同的子表达式。IL 的格式仅支持一个计算结果，即一个符号寄存器。此时忽略条件码。我们假设比较操作会产生一个符号寄存器，其包含小于、等于和大于位。IL分支测试这些符号寄存器位。IL也包含了一组字符串操作，它们会产生符号寄存器结果。这些操作与 IL 中的其他部分一样，都会进行相同的优化。

## 翻译

PL.8d的翻译是通过传统技术完成的。它是自底向上完成的，其中每个段的IL代码都是上下文无关输出的。翻译不针对特殊例子，而是关注源语言实现的整体计算策略。例如，PL.8转换器翻译如下循环语句do

```
do i = m to n;
...
end;
```

为IL等价代码:

![image-20250126231356394](./PL-8编译器概述/image-20250126231356394.png)

因此，重复循环测试的策略是通过翻译实现的。得出m和n是什么（它们可能是常量或者表达式）或者i在循环是否被修改的所需分析，留给优化和寄存器分配在纳入考虑。例如，如果在循环头的代码被发现只包含常量操作数，优化会消除比较和跳转，给有常量边界的循环留下正确的特定场景。

上面的例子也表明了IL的控制操作是简单的条件和无条件跳转。程序的控制结构是从中间语言（IL）中推导出的，因为源代码程序的控制流结构已被消除了。这个方法简化了转换，并且使得优化独立于特定源语言的控制结构。

除了不做本应由优化阶段完成的分析外，翻译器也不进行寄存器分配。相反，该翻译器仅假设当前栈帧可通过某个寄存器寻址。其余所有地址计算均表示为从栈帧内起始点开始的完整寻址路径追踪。例如，获取一个被声明为外部静态变量x需要：

![image-20250215220759289](./PL-8编译器概述/image-20250215220759289.png)

当程序被翻译后，PL.8不会给寄存器重新赋一个特定的值或地址。相反，如果为了获得最好的性能则需要将某个地址或者值赋给寄存器，这些操作将会由常规的优化和寄存器分配进行探索。

## 优化

这个编译器的优化部分执行一系列的独立转换。它们每个都可能被执行多次。重复执行优化的原因是每个优化都可能为其它优化提供新的优化机会，或者引入新的需要优化的代码。通过迭代处理这些交互作用，可以显著降低各个独立转换阶段的复杂性，正如优化过程能够降低翻译阶段的复杂性一样。这个方法需要IL的格式在所有优化期间保持不变性，因此任意转换的结果都可以作为另一个转换的输入。

PL.8中重要的转换有：

  死代码消除 - 消除那些计算结果没有被使用的计算。

  通用子表达式消除 - 消除那些计算结果与之前的仍然可用的计算结果相同或者等价的计算。

  代码移动 - 将计算移动到程序中的另一个位置，使得程序执行得更快。

  常量表达式计算 - 将操作数都是已知的操作在编译时计算出结果。

  强度削减 - 识别出出现在乘积中的迭代变量并且用其它变量替换这些乘积。（需要注意的是转换会将所有的地址，包括数据下标展开为隐式算术计算。因此，按 `do` 循环索引的数组引用将通过此优化进行处理。）

  值标号 - 一个执行通用子表达式消除更有效率的形式，它会将赋值的影响纳入考量。值标号可以在扩展基本块的范围里工作，它的通用子表达式消除是全局的。例如：

![image-20250216000241518](./PL-8编译器概述/image-20250216000241518.png)

在变量改变之前，y+b的计算和a+b的计算是相同的。

  死存储消除 - 非常类似于死代码消除，只是它是应用在存储的值上而不是表达式的结果上。

  线性化 - 通过合并那些无条件关联到单个基本块的后继基本块，消除不必要的分支。

  陷阱消除 - 识别出一些越界值检查的场景，其可以通过适当地修改循环终止测试（9），而被从循环中移除。

  重关联 - 在循环内重排表达式，将所有循环常量值聚集在一起。例如，如果一个表达式具有以下形式：

  (loop varying+loop constant l)+loop constant2，

  其中没有一个计算可以被移出循环。通过重关联表达式为：

  (loop constantl +loop constant2)+loop varying,，

  可以将一个add移出循环。





