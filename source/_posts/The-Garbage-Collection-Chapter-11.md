---
title: The_Garbage_Collection_Chapter_11
tags:
  - hexo
categories:
  - web 应用
date: 2024-11-05 01:03:37
description:
---

# 第11章 运行时接口

一个自动内存分配管理系统的核心是回收器和分配器，它们的算法和数据结构，但是如果它们没有提供合适的访问方法给程序，或者它们自身没有合理地接入底层平台，则几乎无毫无使用价值。此外，有些算法对编程语言的实现有特殊的要求，例如，需要提供一些信息或维护特定不变性。回收器（和分配器）和系统其余部分之间的接口都是本章关注的，包括上层的语言和编译器，以及下面的操作系统和系统库。

我们按顺序考虑以下事情，新对象分配；寻找和调整对象、全局区域和栈里的指针；访问或更新指令或对象的操作（屏障）；修改器和回收器之间的同步；管理地址空间；和使用虚拟内存。

 <!-- more -->

## 分配接口

从编程语言的视角看，一个创建新对象的请求不只是返回一个已分配的对象，也需要按语言和它的实现的全部要求进行初始化。不同的语言覆盖了广泛的需求。需求的一端是C，它只要求一个新分配的指定大小的存储单元 -- 单元里的值是任意的，初始化这个单元完全是程序员的责任。在范围的另一端则是纯函数式语言，如Haskell，其在语言级别上需要为一个新对象的所有域都提供一个新值，无法访问未初始化的对象。

### 加速分配

### 置零

## 寻找指针

为了确定可达性，回收器需要寻找指针。一些算法策略需要指针的精确知识。

### 保守指针查找

### 使用标志值的精确指针查找

### 对象里的精确指针查找

### 全局根里的精确指针查找

### 栈和寄存器里的精确指针查找

### 代码里的精确指针查找

### 处理内部指针

### 处理派生指针

## 对象表

## 来自外部代码的引用

## 栈屏障

之前我们已经描述过栈上指针查找的技术，但假设可以一次性扫描整个线程的整个栈，即系统可以长时间暂停来处理它的整个栈。当一个线程在运行的时候进行栈扫描是不安全的，因此我们要么必须暂停线程几个周期或者让线程帮我们扫描（即，调用一个扫描例程，本质上还是暂停自己）-- 见11.6节

## GC安全点和修改器暂停

在11.2节，我们提到回收器需要知道哪些栈帧槽和哪些寄存器保存了指针的信息。我们也提到这些信息会随着函数中发生垃圾回收的位置（我们会称函数指针为IP）变化而变化。关于哪些地方可以出现垃圾回收有两个关键问题：一个给定的IP对于垃圾回收是不是安全的，栈映射表的大小（详见11.2节压缩映射表），如果越多的IP是合法的则表会越大。

什么情况下一个给定的IP对于垃圾回收是不安全的？大多数系统偶尔会有一些必须完整运行的短代码序列，以保持垃圾回收所依赖的不变量。例如，一个典型的写屏障需要做底层写和一些记录。如果一个垃圾回收发生在这两步之间，则回收器会丢失掉一些对象或者无法更新一些指针。系统通常有一些需要对垃圾回收是原子化的短序列代码（尽管对于真正的并发，它不一定是原子化的）。除了写屏障，还有一些其它的例子如创建一个新栈帧，或者初始化一个新对象。

如果一个系统允许在任意IP上进行垃圾回收，则某种程度上它就更简单 -- 因为它不需要关心线程是否在垃圾回收安全点挂起的问题，垃圾回收安全点简称GC安全点或者GC点。但是，另一方面这样的系统也更复杂，因为它必须在每个IP上支持stack map，或者使用不需要它的技术，如不需要协作的C/C++编译器。如果一个系统允许在大部分IP上进行垃圾回收，则当它需要回收且一个线程被挂起在一个不安全点时，要么它可以向前解释执行挂起的线程直到它到达一个安全点，要么它可以短暂地唤醒线程（概率地）一段时间直到线程执行到安全点。解释执行会遇到低概率的竞争问题，而线程唤醒成功是概率性的不能保证一定唤醒。这样的系统可能也会有巨大的映射开销【Stichnoth et al, 1999】。

许多系统做了相反的选择，只允许垃圾回收在某些严格的安全点进行，然后只需要为这些点生成stack map。保证正确性所需的安全点最小集包含每个分配（因为垃圾回收经常在这里发生）和每个会导致分配或者导致线程挂起等待的函数调用点（因为如果线程挂起，其它的线程可能会导致垃圾回收）。

除了保证正确性所需的最小安全点集，一个系统可能希望允许在更多地地方进行垃圾回收，从而保证垃圾能够快速进行，而无需长时间等待线程到达一个安全点。为了更好地保证这个，每个循环都需要有个安全点；一个简单的规则是在函数的回边放置安全点。此外，需要在每个函数的入口点或者返回点放置安全点，因为有些函数特别是递归的函数，在遇到安全点之前或执行许多的调用和返回。由于这些额外的安全点实际不会执行任何可能触发垃圾回收的操作，它们只是添加了一个是否需要/请求垃圾回收的检查，因此我们称它们为GC-检查点。这种检查给修改器的正常操作增加了额外开销，不过也许影响不大，特别是如果编译器做了些简单的操作来降低这个开销。例如，它可以在一些简单的或者没有循环或函数调用的函数里忽略这种检查。同时也会插入一个额外地循环级别，它可以避免在每个循环迭代里都做检查，而是每n个迭代检查一次。如果检查本身是廉价的，则这些操作可能是没必要的。在任意场景下，频繁操作的开销和不频繁操作的延迟都需要一个明确地抉择。

Agesen【1998】评估了两种导致线程在GC点挂起的方式。一种是轮询，如上所述，线程回会检查一个标志，这个标志表明需要一个回收。另一个是补丁，它涉及修改线程下一个GC点的代码，从而当线程重新开始的时候，它会在下一个GC点暂停。它类似在调试器里放置一个临时断点。Agesen发现补丁的开销远低于轮询，但是同时它也更难以实现，在并发系统里有更多的问题。

在提出GC-检查点的想法时，我们已经引入了回收器和修改器线程之前的握手机制的概念。即时一个系统没有包含真正的并发而只是在一个处理器上复用多个修改器线程，这样的握手可能也是需要的--回收器需要它来说明垃圾回收器的需求，然后唤醒所有没有到达安全点的挂起的线程，从而它可以执行到一个安全点。一些系统只允许线程在安全地挂起，从而避免额外的复杂度，但是因为其它原因导致系统可能无法控制线程的所有方面，因此非常需要这个握手协议。

为了正确性，我们提到了一些握手的部分机制。每个线程维护一个线程变量，其表明在安全点系统的剩余部分是否需要该线程的响应。这个机制不只是可以用作垃圾回收的信号，也可以用在其它事情上。在一个GC检查点上，线程会检查线程局部变量，如果它是非0值，则调用一个系统例程其提取这个变量的数据，根据这个值采取相应的动作。其中一个特定值表示处于垃圾回收的时间点了。当线程注意到这个请求，它会设置另一个线程变量来表示它已经关注了，或者减少一个回收器线程等待的全局变量。系统通常会将线程变量设计成低开销访问，所以这会是一个好方法。

另一个可能性是设置挂起线程保存的线程状态里的处理器标志代码。然后一个GC检查点可以由一组比调用系统例程廉价得多的条件分支组成来响应请求。这个方法只要处理器有多个条件代码集（例如PowerPC）就能工作，且可以保证唤醒的时候不会在外部代码里。如果机器有足够多的寄存器，则其中一个可以专门作为信号寄存器，寄存器的使用几乎和条件码开销差不多。如果线程在外部代码里，当线程从外部代码出来的时候，系统需要一个额外方法来获得关注（除非它已经作为一个安全点挂起了）。劫持返回地址是一种在外部代码完成时获得响应的方法（见11.5节）。

在某些情况下，一个操作系统级的线程间信号量可以作为标志设置和返回地址劫持之外的另一种方案，如同那些由一些POSIX线程的实现提供的，可能是种可行的方案。它在通用可移植性上存在问题，且可能不够高效。部分情况下可能会很慢，因为一些长路径通过操作系统内存创建和分发信号到用户级别的处理句柄上。这会很慢，因为它不但需要一个低级别的处理器中断，同时也需要缓存和TLB的作用。

总的来说，有两个基本的方法：同步通知，也可能称为轮询，和通过一些信号量或者中断的异步通知。每个方法都有它的固有开销，在不同平台上也是不同的。根据不同的架构，轮询可能还需要一定程度的编译器配合。进一步的，异步通知通常需要转为同步，因为扫描栈或者其它需要的操作不是每个时刻都是可以做的。因此，信号处理主要的目标变成设置一个局部标志到线程里，然后线程保证会尽可能快地响应并且完成相应的动作。

我们进一步观察到在线程之间实现同步从而直接扫描栈的过程中，需要考虑硬件和软件的并发问题，针对这些问题，我们在第13章会给出一些背景资料。特别相关的可能是13.7节，它讨论了如何协调线程以从回收的一个阶段到另一个阶段，以及在回收的开始和结束的地方修改器线程需要做的事情。

## 垃圾回收代码

## 读和写屏障

### 工程

### 写屏障精度

### 哈希表

### 顺序存储缓存区

### 溢出操作

### 卡表

### 交叉映射

### 总结卡

### 硬件和虚拟内存技术

### 写屏障机制：总结

### 块表

## 管理地址空间

## 虚拟内存页保护的应用

### 重复映射

### 不可访问页的应用

## 选择堆大小

## 思考问题



