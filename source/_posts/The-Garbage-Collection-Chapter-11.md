---
title: The_Garbage_Collection_Chapter_11
tags:
  - hexo
categories:
  - web 应用
date: 2024-11-05 01:03:37
description:
---

# 第11章 运行时接口

一个自动内存分配管理系统的核心是回收器和分配器，它们的算法和数据结构，但是如果它们没有提供合适的访问方法给程序，或者它们自身没有合理地接入底层平台，则几乎无毫无使用价值。此外，有些算法对编程语言的实现有特殊的要求，例如，需要提供一些信息或维护特定不变性。回收器（和分配器）和系统其余部分之间的接口都是本章关注的，包括上层的语言和编译器，以及下面的操作系统和系统库。

我们按顺序考虑以下事情，新对象分配；寻找和调整对象、全局区域和栈里的指针；访问或更新指令或对象的操作（屏障）；修改器和回收器之间的同步；管理地址空间；和使用虚拟内存。

 <!-- more -->

## 分配接口

从编程语言的视角看，一个创建新对象的请求不只是返回一个已分配的对象，也需要按语言和它的实现的全部要求进行初始化。不同的语言覆盖了广泛的需求。需求的一端是C，它只要求一个新分配的指定大小的存储单元 -- 单元里的值是任意的，初始化这个单元完全是程序员的责任。在范围的另一端则是纯函数式语言，如Haskell，其在语言级别上需要为一个新对象的所有域都提供一个新值，无法访问未初始化的对象。

### 加速分配

### 置零

## 寻找指针

为了确定可达性，回收器需要寻找指针。一些算法策略需要指针的精确知识。实际中，安全地移动位于x的对象到新的位置x'，然后为重用它原来的指针位置需要我们更新所有x的指针到x‘。但是，安全地回收一个对象需要确定程序不在使用它了，但是反之是不正确的：保留一个程序不在使用的对象是安全的，虽然这空间比较低效（虽然它也会导致程序因为缺乏内存而失败）。因此，只要估算是保守的，回收器就可以对非移动对象的引用进行保守估算--它只能过量估算对象的引用，不能少估算。没有环回收的引用计数是保守的，而另一种保守是某些方案缺乏精确指针信息导致的。所以，它们会将一个非指针值视为一个指针，只要这个值能够引用到一个分配对象。我们讨论的第一个技术是保守指针查找，然后是多个区间的精确指针查找。

### 保守指针查找

保守指针查找的基础技术是将连续的同指针大小和对齐的字节序列作为一个可能的指针值，称为模糊指针。因为回收器知道组成堆的内存区域，即时其中一些区域已经被回收了，它也可以从不是指针的值里识别出可能的指针。为了速度，回收器的测试值的指针性的算法必须是高效的。一个典型的方法分为两步。首先，它过滤出不指向内存中任意堆区域的值。如果堆是一个连续区域，则通过范围判定来完成这个识别，或者通过获取指针的高位获得块号，然后查找堆块里的表。第二步是看被引用的堆内存是否实际被分配出去了。它可以通过查询已分配字的位表来检查。例如，Boehm-Demers-Weiser保守回收器【Boehm and Weiser，1988】以区块的形式运作，每块对应特定大小的域。一个块有一个关联的元数据，它可以记录域大小，以及一个位图记录已经分配的和空闲的域。在使用堆边界做范围检查之后，这个算法的下一步是检查引用块是否全部被分配了，如果引用块被分配了，它检查特定的对象是否被分配了。只有这样它才会在标记阶段设置标记位。整个过程，如图11.1所示，有一个典型的路径长度，大概30条RISC指令。

一些语言需要指针指向它引用对象的第一个字，或者特定到对象的特定偏移，如在对象头之后特定字节（见图7.2）。这允许一个保守回收器忽略一些可能的内部指针值，因为它们违反了规范引用指针的格式。在两种场景下构建保守指针查找算法是相对简单的；Boehm-Demers-Weiser保守回收器可以配置成任意一种形式。关于C的保守回收需要注意的是数组的一个内部引用指向数组外的元素是合法的。因此，在这种场景下，C的保守回收器可能需要记录两个对象，或者给数组多分配一个字来避免混淆。一个显式释放的系统可能会在对象间插入一个头，这也可以解决这个问题。在编译器优化的情况下，指针可能会被进一步“损坏”；183页讨论到了这个问题。

因为一个非指针位模式可能会导致保留一个实际不可达的对象，Boehm【1993】设计了一个称为黑名单的机制，当虚拟地址与非指针值相关的时候， 这个机制尝试避免使用这个虚拟地址空间的区域作为堆。实际上，如果回收器遇到一个可能的指针，它指向未分配块的内存，则回收器会拉黑这个块，即不会在分配这个块。即使分配了这个块（一个对象在这个地址上），未来的追踪也会将这个错误的指针识别为真正的指针。这个回收器也支持块用于严格非指针对象，如位图。识别这个数据，不但会加速回收器（因为它不需要扫面这些对象的内容），而且它也能防止因非指针数据的位图模式而导致的过度黑名单。这个回收器未来会优化它的黑名单，即通过区分可能为内部的无效指针和不是内部的无效指针，因为它们来自具有不允许堆存储内部指针的配置的堆。在可能的内部场景下，引用块被所用使用场景拉黑，而在另一个场景下，回收器允许块被用于小的非指针对象（这不会导致太多的浪费）。为了初始化黑名单，回收器在第一次堆分配前会马上做一次回收。它也避免使用地址以许多0结尾的块，因为栈上的非指针数据经常会有这样的值。

### 使用标志值的精确指针查找

### 对象里的精确指针查找

### 全局根里的精确指针查找

### 栈和寄存器里的精确指针查找

例如，Appel【1987】所提倡的一种处理调用栈的方式是堆分配活动记录。【Appel and Shao，1994，1996】和Miller与Rozas【1994】的计数参数也是一样的。一些语言实现使得栈帧和堆对象一样，因此可以统一处理。例如Glasgow Haskell编译器【Cheadle et al，2000】和Non-Stop Haskell【Cheadle et al，2004】。给回收器提供栈内容的特定信息也是可以的，例如Henderson【2002】使用客制化C语言实现Mercury语言，然后Baker et al【2009】进行了改进以支持实时Java实现。

然而，大部分语言因为多种效率的需要给予了栈帧特殊地对待，从而获得最佳性能。我们有三个问题要考虑：

1. 在栈上找到栈帧（活动记录）。
2. 在每一帧里找到指针。
3. 处理传递约定，如参数，返回，寄存器值保存和恢复。

在大部分的系统里不只是回收器需要在栈上寻找栈帧。如异常处理和延续的机制也需要解析栈，更不用说栈检查在调试中的巨大价值，以及在某些系统里是必须的，如Smalltalk。当然给程序员的视图可能是一个非常干净的视图，而不是更优化和‘原始’布局的实际栈帧。因为栈解析通常是有用的，栈帧布局约定通常是为它提供的。例如，许多设计会在每帧里包含一个动态链域，其指向前一帧。其它的域通常位于帧引用点的固定偏移里（帧指针或者动态链的地址）。它们可能会包含返回地址，静态链等等。系统也会提供一个映射表，可以根据返回地址确定该地址所在的函数。在一个非回收的系统里，这只会出现在调试器符号表里，但是许多管理系统会访问程序里的这张表，所以它是加载或者代码生成信息的一部分，而不只是辅助调试器表。

为了寻找栈帧里的指针，一个系统需要显式地添加栈映射信息到每一帧来帮助回收器。这个元数据由位图组成，标记了哪些栈帧域包含指针，或者系统会将帧分为包含指针区和不包含指针部分，元数据会给出每个区的大小。需要注意的是每个函数都会有一些初始化指令，在这期间新栈帧存在了但是没有完全初始化。在这期间回收会有问题；参考我们后面在11.6节关于垃圾回收安全点和修改器握手的讨论。或者我们可以通过仔细的初始代码回收器分析来获得，同时通过小心地使用机器上的push指令

### 代码里的精确指针查找

### 处理内部指针

### 处理派生指针

## 对象表

## 来自外部代码的引用

## 栈屏障

之前我们已经描述过栈上指针查找的技术，但假设可以一次性扫描整个线程的整个栈，即系统可以长时间暂停来处理它的整个栈。当一个线程在运行的时候进行栈扫描是不安全的，因此我们要么必须暂停线程几个周期或者让线程帮我们扫描（即，调用一个扫描例程，本质上还是暂停自己）-- 见11.6节

## GC安全点和修改器暂停

在11.2节，我们提到回收器需要知道哪些栈帧槽和哪些寄存器保存了指针的信息。我们也提到这些信息会随着函数中发生垃圾回收的位置（我们会称函数指针为IP）变化而变化。关于哪些地方可以出现垃圾回收有两个关键问题：一个给定的IP对于垃圾回收是不是安全的，栈映射表的大小（详见11.2节压缩映射表），如果越多的IP是合法的则表会越大。

什么情况下一个给定的IP对于垃圾回收是不安全的？大多数系统偶尔会有一些必须完整运行的短代码序列，以保持垃圾回收所依赖的不变量。例如，一个典型的写屏障需要做底层写和一些记录。如果一个垃圾回收发生在这两步之间，则回收器会丢失掉一些对象或者无法更新一些指针。系统通常有一些需要对垃圾回收是原子化的短序列代码（尽管对于真正的并发，它不一定是原子化的）。除了写屏障，还有一些其它的例子如创建一个新栈帧，或者初始化一个新对象。

如果一个系统允许在任意IP上进行垃圾回收，则某种程度上它就更简单 -- 因为它不需要关心线程是否在垃圾回收安全点挂起的问题，垃圾回收安全点简称GC安全点或者GC点。但是，另一方面这样的系统也更复杂，因为它必须在每个IP上支持stack map，或者使用不需要它的技术，如不需要协作的C/C++编译器。如果一个系统允许在大部分IP上进行垃圾回收，则当它需要回收且一个线程被挂起在一个不安全点时，要么它可以向前解释执行挂起的线程直到它到达一个安全点，要么它可以短暂地唤醒线程（概率地）一段时间直到线程执行到安全点。解释执行会遇到低概率的竞争问题，而线程唤醒成功是概率性的不能保证一定唤醒。这样的系统可能也会有巨大的映射开销【Stichnoth et al, 1999】。

许多系统做了相反的选择，只允许垃圾回收在某些严格的安全点进行，然后只需要为这些点生成stack map。保证正确性所需的安全点最小集包含每个分配（因为垃圾回收经常在这里发生）和每个会导致分配或者导致线程挂起等待的函数调用点（因为如果线程挂起，其它的线程可能会导致垃圾回收）。

除了保证正确性所需的最小安全点集，一个系统可能希望允许在更多地地方进行垃圾回收，从而保证垃圾能够快速进行，而无需长时间等待线程到达一个安全点。为了更好地保证这个，每个循环都需要有个安全点；一个简单的规则是在函数的回边放置安全点。此外，需要在每个函数的入口点或者返回点放置安全点，因为有些函数特别是递归的函数，在遇到安全点之前或执行许多的调用和返回。由于这些额外的安全点实际不会执行任何可能触发垃圾回收的操作，它们只是添加了一个是否需要/请求垃圾回收的检查，因此我们称它们为GC-检查点。这种检查给修改器的正常操作增加了额外开销，不过也许影响不大，特别是如果编译器做了些简单的操作来降低这个开销。例如，它可以在一些简单的或者没有循环或函数调用的函数里忽略这种检查。同时也会插入一个额外地循环级别，它可以避免在每个循环迭代里都做检查，而是每n个迭代检查一次。如果检查本身是廉价的，则这些操作可能是没必要的。在任意场景下，频繁操作的开销和不频繁操作的延迟都需要一个明确地抉择。

Agesen【1998】评估了两种导致线程在GC点挂起的方式。一种是轮询，如上所述，线程回会检查一个标志，这个标志表明需要一个回收。另一个是补丁，它涉及修改线程下一个GC点的代码，从而当线程重新开始的时候，它会在下一个GC点暂停。它类似在调试器里放置一个临时断点。Agesen发现补丁的开销远低于轮询，但是同时它也更难以实现，在并发系统里有更多的问题。

在提出GC-检查点的想法时，我们已经引入了回收器和修改器线程之前的握手机制的概念。即时一个系统没有包含真正的并发而只是在一个处理器上复用多个修改器线程，这样的握手可能也是需要的--回收器需要它来说明垃圾回收器的需求，然后唤醒所有没有到达安全点的挂起的线程，从而它可以执行到一个安全点。一些系统只允许线程在安全地挂起，从而避免额外的复杂度，但是因为其它原因导致系统可能无法控制线程的所有方面，因此非常需要这个握手协议。

为了正确性，我们提到了一些握手的部分机制。每个线程维护一个线程变量，其表明在安全点系统的剩余部分是否需要该线程的响应。这个机制不只是可以用作垃圾回收的信号，也可以用在其它事情上。在一个GC检查点上，线程会检查线程局部变量，如果它是非0值，则调用一个系统例程其提取这个变量的数据，根据这个值采取相应的动作。其中一个特定值表示处于垃圾回收的时间点了。当线程注意到这个请求，它会设置另一个线程变量来表示它已经关注了，或者减少一个回收器线程等待的全局变量。系统通常会将线程变量设计成低开销访问，所以这会是一个好方法。

另一个可能性是设置挂起线程保存的线程状态里的处理器标志代码。然后一个GC检查点可以由一组比调用系统例程廉价得多的条件分支组成来响应请求。这个方法只要处理器有多个条件代码集（例如PowerPC）就能工作，且可以保证唤醒的时候不会在外部代码里。如果机器有足够多的寄存器，则其中一个可以专门作为信号寄存器，寄存器的使用几乎和条件码开销差不多。如果线程在外部代码里，当线程从外部代码出来的时候，系统需要一个额外方法来获得关注（除非它已经作为一个安全点挂起了）。劫持返回地址是一种在外部代码完成时获得响应的方法（见11.5节）。

在某些情况下，一个操作系统级的线程间信号量可以作为标志设置和返回地址劫持之外的另一种方案，如同那些由一些POSIX线程的实现提供的，可能是种可行的方案。它在通用可移植性上存在问题，且可能不够高效。部分情况下可能会很慢，因为一些长路径通过操作系统内存创建和分发信号到用户级别的处理句柄上。这会很慢，因为它不但需要一个低级别的处理器中断，同时也需要缓存和TLB的作用。

总的来说，有两个基本的方法：同步通知，也可能称为轮询，和通过一些信号量或者中断的异步通知。每个方法都有它的固有开销，在不同平台上也是不同的。根据不同的架构，轮询可能还需要一定程度的编译器配合。进一步的，异步通知通常需要转为同步，因为扫描栈或者其它需要的操作不是每个时刻都是可以做的。因此，信号处理主要的目标变成设置一个局部标志到线程里，然后线程保证会尽可能快地响应并且完成相应的动作。

我们进一步观察到在线程之间实现同步从而直接扫描栈的过程中，需要考虑硬件和软件的并发问题，针对这些问题，我们在第13章会给出一些背景资料。特别相关的可能是13.7节，它讨论了如何协调线程以从回收的一个阶段到另一个阶段，以及在回收的开始和结束的地方修改器线程需要做的事情。

## 垃圾回收代码

## 读和写屏障

### 工程

### 写屏障精度

### 哈希表

### 顺序存储缓存区

### 溢出操作

### 卡表

### 交叉映射

### 总结卡

### 硬件和虚拟内存技术

### 写屏障机制：总结

### 块表

## 管理地址空间

## 虚拟内存页保护的应用

### 重复映射

### 不可访问页的应用

## 选择堆大小

## 思考问题



