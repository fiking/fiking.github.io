---
title: 指令选择的调查
tags:
  - compiler
categories:
  - dissertation translation
  - compiler
date: 2022-10-03 14:54:48
mathjax: true
description:

---

## 摘要

指令选择是代码生成中三个主要的优化问题之一 -- 其它两个是指令调度和寄存器分配。指令选择器的任务是将来自目标独立表示的输入程序转换为一个特定目标的形式，期间会充分利用可以使用的机器指令。因此，指令选择是生成在特定目标机器上既正确又高效运行的代码至关重要的一部分。

尽管自 1960 年代后期以来一直在研究，但是这个领域的上一篇综合调查是写于 30 多年前的了。因为，自从它发表之后出现了许多新的方法和技术，所以需要对当前的文献进行新的审查。这个报告解决了这个需求，给出了一个广泛的调查，以及指令选者过时的方法和最新方法的分类。因此，这个报告取代和扩展了之前的调查，并且尝试着指出未来的研究方向。

 <!-- more -->

## 简介

任何软件的每部分实现承诺 -- C 写的基于 GUI 的 Windows 应用，数学计算的高性能 FORTRAN 程序，或者 Java 写的智能手机 app -- 都需要一种或者另一种形式的编译器。它的核心目的是转换一个输入程序的源代码 -- 相关高级编程语言写的 -- 到一个等价的低级程序代码表示，其对应于特定的目标机器。程序代码转变为机器代码 -- 与编译相比是一个相对容易的任务 -- 然后可以在指定的目标机器上执行。最后，编译器一直是，并且很可能永远是利用现代技术的重用推动者。因此，自 1940 年代第一台计算机开始出现以来，一直在积极研究中，编译是计算机科学中最古老和研究最多的领域之一。

为了达成这个任务，编译器需要处理范围广泛的中间问题。其中一些问题包括语法分析，转变为中间表示，目标独立优化，以及代码生成。代码生成是生成目标机器相关的程序代码的过程，依次由三个子问题组成 -- 指令选择，指令调度，以及寄存器分配 -- 本报告关注第一个问题。

之前的一些在某种程度上讨论指令选择的调查是由 Cattell[45]，Ganapathi 等[116]，Leupers[169]，以及 Boulytchev 和 Lomov[33] 产生的。但是，最后一篇广泛的调查 -- Ganapathi 等的 -- 是 30 年前发布的。而且，经典的编译器书只是简短的讨论指令选择，因此提供的见解比较少；在构成编译器书的 4600 多页综合正文中[8，15，59，96，173，190，262]，少于 160 页 -- 其中有很大的重叠，且基本上只讨论树覆盖 -- 用在指令选择上。因此，需要对该领域进行新的，实时的研究。这个报告解决了这个需要，通过描述和回顾了已经存在的方法 -- 包括过去和现在的 -- 指令选择，因此取代和扩展了之前的调查。

这篇报告的结构如下。本章剩余部分介绍和描述了指令选择的任务，比较了已经存在的方法解释了通用的问题，且简要介绍了有关代码生成的第一篇论文。然后第 2 章到第 5 章，分别讨论了指令选择的基本原则：第 2 章介绍了宏展开；第 3 章讨论了树覆盖；其在第 4 章和第 5 章扩展到了 DAG 和图覆盖。最后，第 6 章给出了一个结论结束这个报告，其中我尝试识别出未来研究的方向。

这篇报告也包含了几个附录。附录 A 给出了一张表总结了本报告中涵盖的所有方法，附录 B 中有一张图标说明了文章出版的时间线。为了一些必要的背景信息，附录 C 提供了一些图的正式定义。附录 D 中包含了一些术语和概念的分类，用于整个报告，促进讨论且避免混淆。最后，附录 E 中提供了本文档的修订日志。

### 什么是指令选择 ？

如本章一开始声明的，编译器的核心目的是将高级别源码写的程序转换成低级别机器码，其是将要执行程序的特定硬件平台特有的。这个源码可以用一些编程语言表达（如，C，Java，Haskell 等），然后硬件通常是一个特定模型的处理器。后面正在编译的程序称为*输入程序*，然后它被编译的硬件称为*目标机器*（这些定义在附录 D 中也可以找到）。

#### 编译器内部

为了给指令选择一个上下文，让我们简要地检查下编译器做了哪些事情。图 1.1 给出了大部分编译器的基础设施。首先是*前端*解析，验证，然后转换输入程序的源码到一个等价形式即*中间表示*，或者简写为 IR。IR 代码是编译器内部使用的格式，它还将编译器的其余部分于特定编程语言的特征隔离开来。因此，通过简单地为每个语言提供一个前端，就可以在相同的编译器中支持多个编程语言。

{% if 1 == 1 %} 
  {% asset_img figure_1_1.png title %}
{% else %}
![](H:\Blogs\fiking\source\_posts\指令选择的调查\figure_1_1.png)

{% endif %}

执行一系列目标机器无关的优化之后 -- 如，死代码消除和评估带有常量的表达式（被称为常量折叠） -- IR 代码被*代码生成器*后端转换为一组机器相关的指令，称为*汇编代码*；这是允许输入程序在特定目标机器上可以执行的部分。为了做这个，我们需要决定哪个目标机器的机器指令可以用于实现 IR 代码；这是*指令选择器*的职责。对于已选择的指令，我们也需要决定它们出现在汇编代码中的顺序，这是*指令调度器*关心的事。最后，我们必须决定如何使用目标机器上可用的有限寄存器集，通过*寄存器分配器*来管理。最后两个任务超出了本报告的范围，不会在进一步详细地讨论了。

指令选择器主要是要选出可以实现与输入程序相同期望行为的机器指令，然后次要目标是，要产生高效的汇编代码。我们将其重新表述为下面的子问题：

1. *模式匹配* -- 检查何时何地可以使用的某条指令；然后
2. *模式选择* -- 当多个选项存在的时候，决定当前场景中可以选择的指令。

第一个子问题与寻找机器指令候选有关，而第二个子问题与从这些候选指令选出一个子集有关。有些方案将两个子问题合并到了一步，但大部分都是保持两者分开的，主要区别是他们如何解决模式选择的问题。通常后者被表述为一个优化问题，其中每条机器指令都被赋予了一个开销，目标是最小化已选择的指令的总开销。根据优化准则，成本通常是反映目标机器执行给定机器指令所需的周期数。

#### 目标机器的接口

指令选择期间可以使用的有效机器指令集是由目标机器*指令集架构*（ISA）决定的。大部分的 ISAs 提供了丰富且多样的指令集，它们的复杂范围从执行简单只有一个操作的简单指令 -- 如，算术加法，到高复杂的指令--如，拷贝一个内存位置的内容到另一个位置，增加一个地址指针，以及重复直到遇到某个停止值。因为指令集很少是正交的，一个特殊的操作集总是存在超过多种实现方式。例如，表达式$a + (b \times c)$ 的计算，可以通过首先执行一个 mul 指令 -- 其实现了 $d\leftarrow b\times c$ -- 然后紧跟着一条 add 指令实现了$e\leftarrow a + d$来计算；或者它可以通过执行一条单一的 mulacc 指令来计算，它实现了 $a \leftarrow a + (b \times c)$。

根据目标机器的特性，在执行特定任务时，一些指令序列比其的更高效。对于数字信号处理器(DSPs)更是如此，其为了提高某个算法的性能，给出了许多的客制化机器指令。根据 1994 年的研究[254]，从 C 程序到目标为 DSPs 的编译器生成的汇编代码的时钟周期固有开销是手写汇编代码的 1000% 多，因为编译器未能充分利用目标机器的能力。最后，生成的机器代码的质量高度依赖于编译器利用硬件相关的特性和资源的能力，其中指令选择器是达成这一目标的关键（但是不是唯一的）组件。

### 编译不同方法的问题

如同我们在前一节看到的，ISA 由许多不同类型的机器指令组成。 但是，当前所有指令选择方法的共同特定是，没有一个可以处理 ISA 中的每一条有效指令的。最终，大多数提出新指令选择技术的论文讨论的指令集都有所不同。例如，早期文献中，“复杂机器指令”是指使用不同复杂度的方案计算内存地址的内存加载和存储指令。这些方案称为*地址模式*，使用合适的地址模式可以降低代码大小，同时提高性能。举个例子，让我们假设我们需要从一个 驻留在内存的1-字节数据的数组中的特定位置加载一个值。因此，我们想要的值的内存地址是 @A + offset，其中 @A 指的是第一个元素的内存地址，通常叫*基址地址*。一个合理获取这个值的方法是首先执行一个 add 指令来计算 @A + offset 到一些寄存器 $r_x$ ，然后执行一条 load 指令其从 $r_x$ 中获取内存地址。这样的 load 指令被认为是有*绝对*或*直接*地址模式。但是，如果ISA 提供了一条带有*索引*地址模式的 load 指令 -- 其地址获取的地方是基础值加上偏移 -- 这样我们就可以远离只使用一条机器指令了。相比之下，在现代指令选择方法中高效处理这样的地址模式是微不足道的，更复杂的机器指令通常是产生多个值的，或者是只能在特定场景下使用的（或不能使用的）。

为了解决这个问题，使得我们可以比较指令选择的不同方案，我们将会引入定义一组属性，每个都与某类机器指令相关。

#### 机器指令属性

*单输出指令*

最简单的机器指令种类是一组*单输出*的指令。这些只产生单个可见的输出，“可见”的意思是一个值可以被程序读和访问。这包含了所有实现单操作数的指令（如，加法，乘法，和位操作如 OR 或者 NOT），也包含了许多复杂的指令，其实现了几个操作数如刚才讨论的带有复杂地址模式的内存操作（如，将基址寄存器 $r_x$ 加上偏移标识的寄存器 $r_y$ 加上一个立即数得到的内存位置里的值加载到寄存器$r_d$）；只要可观察的输出值可以构成单一值，一个单输出指令就可以是任意复杂的。

*多输出指令*

如预期的，多输出指令从一个相同的输入产生了多个可观察的输出值。一个包含 divrem 指令的例子，它计算了两个输入的商和余数，算术指令也一样，除了计算结果，也设置状态标志。一个状态标志（也称为条件标志或者条件码）是每一位都表示结果的一个额外信息，如，一个进位溢出或结果是 0。因为这个原因，这样的指令总是被说是有副作用的，但是实际上这些位只不过是指令额外产生的信息，因此被认为是多输出的指令。加载和存储指令会访问内存中的值，然后增加地址指针的值，也会被认为是多输出指令。

*不相交输出指令*

从许多不同输入值产生多个可观察值的机器指令被认为是不相交输出指令。它们类似于多输出的指令，除了后者所有的输出值都是来自于相同输入值的。另一种形式说则是如果每个相关的输出形成表达式地图，所有的这些图都是相互不相交的；我们会在下一章解释这个图是如何形成的。不相交指令典型的包含 SIMD（单指令，多数据）和向量指令，其同时在许多不同的输入值上执行相同的操作。

*内部循环指令*

内部循环指令表示行为是执行一些内部循环的机器指令。例如，TI TMS320C55x [247] 处理器提供了一条 RPT k 指令，重复执行后面的指令 k 次，k 是立即数作为机器指令的一部分给出。这些指令是最难利用的指令之一，今天要利用它们要么通过客制化优化路径，要么通过编译器特殊的支持。

*相互依赖的指令*

最后一类是相互依赖的指令。这是指那些携带额外限制的指令，这些限制会在指令以特定的方式组合的时候出现。一个包含 ADD 指令的例子，这条指令来自 TMS320C55x 指令集，如果 ADD 使用特定的寻址模式，则它不能与 RPT k 指令组合在一起。如同我们将在这个报告里看到的，这是另一类大多数指令选择器都难以处理的机器指令，因为它们通常不满足基础技术所作的一组假设。此外，它们只在某些场景下出现。

#### 最优指令选择

当使用最佳指令选择这个术语时，大部分文献都假设 -- 通常是隐式的 -- 有如下的定义：

定义. *一个指令选择器，能够以开销 $c_i$ 建模一组机器指令 I，是最优的，只要对任意给定输入程序 P，它选出了一个集合$S\subseteq I$ s.t. S 实现了 P，且不存在其它的集合 $S'$ 也实现了 P，其中 $\sum_{s'\in S^{'C}s'} < \sum_{s\in S^Cs}$*。

换句话说，通过这个指令选择器处理和利用相同的机器指令，无法实现更低成本的汇编代码，则认为这个指令选择器是最优的。

这个定义有两个缺陷。首先，“可以被建模的机器指令”的条文限制了最优性的讨论，即指令选择器是否已经极致地利用了指令的讨论限制在它能处理的指令集上。其它的，不支持的机器指令，就算能产生更高效的汇编，也被简单的忽略了。尽管这个定义使得支持相同机器指令的指令选择器可以相互比较，但是它也允许将处理不同指令集的两个指令选择器识别成都是最优的，即使其中一个比另一个明显能产生更高效的代码。忽略违规条文可以移除这个问题，但也会使得现有的所有指令选择技术都变成是次优的。除了最简单的 ISAs，对于特定的输入程序，似乎总是存在一些机器指令可以提高代码质量，但是不能被指令选择器处理。

更要紧的是另一个问题，两个可比较的指令选择器可能会选择不同的指令，从指令选择的角度来看两个都可以被认为是最优的，却最终产生指令不成比例的汇编代码。例如，其中一组指令可能会使得后续的指令调度和寄存器分配能更好的运行，而另一组则不行。这强调了代码生成的一个众所周知的特性：指令选择，指令调和寄存器分配是相互关联在一起，形成一个复杂系统，来影响最终编译后的汇编代码的质量，且经常出现的是反直觉的方式。因此，为了产生真正最优的代码，三项任务需要协同解决。有许多的研究已经开始设计这样的系统了（有些本报告覆盖到了）。

因此，将最优指令选择作为一个孤立概念的想法是徒劳的，然后如果一个指令选择方法宣称是“最优的”，则明智的做法是密切关注它支持的机器指令集。不幸地是，这个概念已经在编译器社区中牢牢地确立了，并且渗透到文献中了。由于这个原因 -- 且没有更好的选择 -- 我将在本报告中遵守这个定义，但尽量少使用它。

### 指令选择的史前史

代码生成的早期论文是从 1960 年代早期开始出现的 [13，99，193，214]，它们主要关注基于累加寄存器的目标机器上如何计算算术表达式。对于一条指令而言，一个累加寄存器是可以同时作为输入值和目的的寄存器的（如，$a \leftarrow a + b$），在早期的机器中很流行，因为它可以用比较少的寄存器来构建处理器。虽然这个简化了硬件制造过程，但是，不容易自动生成表达式的累加寄存器和内存间的最小传输数量的汇编代码。

在 1970 年代，Sethi 和 Ullman [228] 将这些想法扩展到了带有 n 个通用寄存器的目标机器上，然后给出了一个评估带有通用子表达式的算术语句的算法，可以生成尽可能少语句的代码。后来，Aho 和 Johnson[3] 扩展了这个工作，应用动态规划开发了一个代码生成的算法，可以处理带有类似间接地址等更复杂地址模式的目标机器。本报告后面将会在重新给出这个方法，因为后续许多指令选择的方法都受到这个技术的影响。

这些早期技术的共同点是指令选择的问题被有效的忽略和规避。例如，Sethi 和 Ullman 以及 Aho 和 Johnson 的方法都假设了目标机器具有简洁的数学性质，没有任何的奇异机器指令和多个寄存器分类。由于没有或者很少有机器具有这样的特性，所有这些算法在实际设置中都无法直接应用。

由于缺乏正式的方法，第一个指令选择器通常都是手工写的，基于临时的算法完成的。这意味着高效和可移植性之间的权衡：如果指令选择器太通用，则生成的汇编代码可能无法执行；如果它过于紧密地针对特定目标机器量身定制，则会限制编译器支持其它的目标机器。因此，移植这样的指令选择器涉及到手工修改和基础算法的重写。对于特殊的机器，带有多有个寄存器类且需要不同的指令来访问不同的类，原始的指令选择器甚至可能根本不能用。

但即使指令选择器是要以有助于编译器移植的方式来构建，也不是很清楚如何实现这一目标。下一章中，我们将研究解决这个问题的第一种方法。

## 宏展开

第一篇介绍将指令选择作为一个独立问题来处理的方法的论文出现在 1960 年代后期。在这些设计中，指令选择通过在由输入程序组成的代码上进行模板匹配来驱动。命中后，使用匹配的程序字符串作为参数，执行相对应的宏。每种语言结构，共同构成了表达输入程序的编程语言，通常都有自己的宏定义，可以输出目标机器合适的汇编代码。多个语言构造也可以合并成单个模板，从而更好地利用指令集。对于一个给定的输入程序，对于一个给定的输入程序，指令选择器将会以遍历输入程序的程序方式运行，将代码与模板匹配，然后执行匹配后的宏。如果一些文本无法匹配到任何的模板，则指令选择会失败，然后报告一个错误，表明它无法为特定的输入程序，产生特定的目标机器上的有效汇编代码（这种情况最好不要发生）。

{% if 1 == 1 %} 
  {% asset_img s_2_1.png title %}
{% else %}
![](H:\Blogs\fiking\source\_posts\指令选择的调查\s_2_1.png)

{% endif %}

因此，模板匹配的过程对应与前一章描述的模式匹配问题，在多个匹配宏间选择的过程对应于模式选择的问题。但是，据我所知，所有的宏展开的指令选择器都是立即选择首先匹配到的宏，从而使得后一个问题变得轻而易举。

通过保持这些宏的实现与核心实现的分离 -- 核心指的是指令选择中模板匹配和宏执行的部分 - 减少了将编译器移植到不同目标机器的工作量，较早的时候，整体的方式经常要重写整个代码生成器的后端。

### 朴素的宏展开

## 树覆盖

如同我们在前一章见到的，基于宏展开的大部分指令选择器的主要限制是，展开的范围限制在了表达式树的单一 AST 或者 IR 节点上了。这有效地排除了对许多机器指令的利用，导致了产生的代码质量低。另一个问题是宏展开指令选择器通常将模式匹配和模式选择合并到单步里去了，因此无法考虑机器指令的组合，然后选择产生最”高效“汇编代码的那个。

这些问题可以通过采用另一种指令选择原理来解决，称为*树覆盖*。这个也是文献中能找到的大部分指令选择技术的原理，从而导致这章是本报告中最长的章节。

### 原理

让我们假设输入程序是用一组表达式树表示的，这个我们在上一章中已经很熟悉了（见第 10 页）。让我们进一步假设每条机器指令都可以类似地建模成另一个表达式树，然后为了区分通过输入程序建立的表达式树和通过机器指令建立的，我们将后者称为树模式，或简称为模式。然后指令选择的任务就可以归约成寻找一组树模式，使得表达式树上的每个节点都至少被一个模式覆盖了。这里我们可以清楚地看到模式匹配和模式选择组成了指令选择中的两个问题：对于前者，我们需要寻找哪些是适合给定表达式树的树模式；然后对于后者，我们会从这些模式中选出一个子集，生成表达式树的一个有效覆盖。对于大部分目标机器而言，会存在大量的重叠 - 即，一个树模式可能是局部或者全匹配的，节点会被表达式树的另一个模式匹配 - 我们通常希望尽可能少地使用树模式。这有两个原因：

- 争取最少数量的模式意味着选择较大的树模式而不是较小的。这反而使得可以利用更复杂的机器指令，其通常可以生成更高质量的代码。
- 已选择的模式之间的重叠数量是有限的，意味着输入程序中相同操作只在需要的时候被重新实现成多条机器指令。将冗余工作保持到最低限度是提高性能和减少代码大小的另一个关键因素。

{% if 1 == 1 %} 
  {% asset_img s_2_2.png title %}
{% else %}
![](H:\Blogs\fiking\source\_posts\指令选择的调查\s_2_2.png)

{% endif %}

作为一个通用化的最优方案，通常不会定义成最小的已选择模式的数量；而是定义为最小的已选择模式的总开销。这样允许选择的模式开销可以适应所需优化的标准，虽然模式数量和总开销之间总是有强的相关性。但是，如同第 1 章强调的，被认为是指令选择的最佳解决方案的，不一定是最终汇编代码的最佳解决方案。而且，我们只能考虑存在合适的树模式的机器指令。寻找树匹配问题的最优方案不是一个平凡的任务，如果只允许某些模式组合存在，它会变得更少。可以确定的是，大多数人都很难相处一种有效的方法可以找到所有的有效树模式匹配。因此，我们从探索解决第一个方法开始，其可以解决模式匹配的问题，但不一定可以处理模式选择的问题，然后逐渐过渡到可以做到这些事情。

### 第一种使用树模式匹配的技术

1972 年和 1973 年 Wasilew[255] 和 Weingart[256] 发表了已知的第一篇使用树模式匹配来描述代码生成技术的论文（由于缺乏第一手资料，我们在本报告中将仅讨论两者中的前者）。根据 [45，116] Weingart 的设计使用了单个模式树 -- Weingart 称这个为*歧视网* - 它是从一个声明性的机器描述中自动派生出来的。使用单个树，Weingart 认为，是一种紧凑而有效的表示方式。然后构建 AST 的过程被扩展成同时将每个新的 AST 节点压入栈上。当一个新节点出现时，通过比较栈上的节点和模式树种的当前节点的子节点，逐步遍历模式树。当一个搜索过程到达模式树的叶子节点时，就找到了一个模式匹配，于是输出匹配关联的机器指令。

比起早期的宏展开指令选择器（即，DavidsonFraser 之前的那些），Weingart 的方法扩展了机器指令以支持那些扩展到多个 AST 节点的指令。但是，这个技术实际应用中遇到了几个问题。首先，对于特定的目标机器，构造模式树满足高效的模式匹配被证明是困难的；众所周知，Weingart 特别与 PDP-11 作斗争了。第二，它假设目标机器上至少存在一条机器指令与 AST 上的一个特定节点类型对应，但是对于某些特定编程语言和目标机器的组合，事实证明并非如此。Weingart 通过引入额外的模式部分地解决了这个问题，称为转换模式，它使得 AST 上不匹配的部分被转换成，有希望被某些模式匹配的形式，但是这个不得不手动做，有可能会使得编译器陷入无限循环中。第三，就像它的前辈宏扩展一样，一旦找到匹配项，该过程就会立即选出一个模式。

另一个早期的模式匹配技术是由 Johnson [143] 开发的，实现在 PCC（可移植的 C 编译器）上了，它是一个著名的系统，是第一个与 Unix 一起发布的标准 C 编译器。Johnson 基于 Snyder[233] 早期做出的 PCC -- 它是我们在上一章的 2.2.2 节讨论过的 -- 但是用基于树重写的技术替换了朴素宏展开的指令选择器。对于每个机器指令，表达式树是和重写规则，子目标，资源需求，以及逐字输出的汇编字符串一起形成的。这些信息通过一个机器描述给出，如图 3.1，允许多个简单的模式浓缩成一个简单的声明。

然后模式匹配相对就直接了：对于表达式树中一个给定的节点，这个节点与每个模式的根节点比较。如果匹配上，则对模式中的相关子树都做类似的检查。只要模式中的所有叶子节点都可达，则找到一个匹配。因为这个算法 -- 图 3.2 给出了它的伪代码 -- 展示了二次方的执行时间，尽量减少冗余检查的数量是有帮助的。这是通过维护一组代码目标来完成的，这些目标以整数的形式编码到了指令选择器中。因为历史原因，这个整数被称为*cookie*，每个模式都有相关的 cookie 表明它在哪个场景下是有效的。如果 cookies 和模式都匹配上，则尝试分配模式所需的任意资源（如，如果一个模式可能会需要任意数量的寄存器）。如果成功，则输出相应的汇编字符串，然后表达式树中的已匹配节点被替换成重写规则指定的单个节点。匹配重写的规则一直重复直到表达式树只由单个节点组成，这意味着整个表达式树已经成功地被转成汇编代码。但是，如果没有模式匹配上，指令选择器会进入一个启发式模式，其中表达式树会被部分地重写直到找到一个模式。例如，为了匹配一个  a = reg + b 的模式，一个 a += b 的表达式首先被重写为 a = a + b，然后另一个规则尝试强制一个操作数放入寄存器中。

{% if 1 == 1 %} 
  {% asset_img figure_3_1.png title %}
{% else %}
![](H:\Blogs\fiking\source\_posts\指令选择的调查\figure_3_1.png)

{% endif %}

{% if 1 == 1 %} 
  {% asset_img figure_3_2.png title %}
{% else %}
![](H:\Blogs\fiking\source\_posts\指令选择的调查\figure_3_2.png)

{% endif %}

虽然它在当时是很成功的，但是 PCC 有几个缺点。就像 Weingart，Johnson 的技术使用了启发式重写规则来处理不匹配的场景。缺乏形式化的验证方法，当前的规则集总是存在不足的风险，并可能会导致编译器永远无法终止某些输入程序。Reiser [215] 还指出了，其所研究的 PCC 版本仅支持具有最大高度为 1 的一元和二元模式，因此，排除了许多带有复杂地址模式的指令。最后，PCC -- 以及目前为止讨论的所有其它方法 -- 在选择模式时依旧坚持着*第一匹配第一个使用*的原则。

### 使用 LR 解析自下而上覆盖树

如之前所述的，第一种方式中的一个常见缺陷是（i）他们应用了最贪婪的模式选择，（ii）且通常缺乏正式的方法论。相反，语法分析 -- 这是解析输入程序源码的任务 -- 可以说是最好理解的编译领域了，且它的方法也产生了完全由表驱动的解析器，这种解析器非常快速且资源高效的。

#### Glanville-Graham 方法

1978 年 Glanville 和 Graham [121] 提出了一篇开创性的论文，描述了语法分析技术是如何可以用到指令选择上的。后续的实验和评估表明这种设计 -- 我们将其称为 Glanville-Graham 方法 -- 被证明比当代方法[9, 116, 126, 127]更简单、更通用。而且，由于其表驱动的性质，汇编代码可以快速地生成（虽然第一个实现与当时使用的其它指令选择器相当）。最后，Glanville-Graham 方法已经被认为是这个领域最重要的突破之一了，并且这些想法以某种方式影响了许多后来的技术。

*将机器指令表示为语法*

首先，移除算术表达式中必要括号而不会导致歧义的一个已知方法是使用*波兰前缀表示法*。例如，$1+(2+3)$ 可以写成$+1+2\ 3$，含义是相同的。Glanvile 和 Graham 意识到使用这种形式机器指令可以被表达成一个基于 BNF（Backus-Naur 范式）的上下文无关语法。这个概念在大多数编译器书本中都有很好的描述 -- 我推荐的[8] -- 因此我们只进行一个简短的介绍。

{% if 1 == 1 %} 
  {% asset_img s_3_1.png title %}
{% else %}
![](H:\Blogs\fiking\source\_posts\指令选择的调查\s_3_1.png)

{% endif %}

一个上下文无关的语法由一组*终结符*和*非终结符*组成，这两个我们都称为*符号*。我们将会通过不同的书写方式来区分两者，总是以首字母大写的方式来书写终结符（如，Term），而非终结符整个都是小写的形式（如，nt）。对于每个非终结符都存在一个或多个如下形式的*产生式*：
$$
lhs \rightarrow Right\ hand\ Side ...
$$
产生式基本上指定了如何用另一个非终结符（左侧）替换一组特定符号组合（右侧）。由于非终结符可以出现在产生式的两边，因此大部分语法允许无限的替代链，这是上下文无关语法一个强大的特性。从递归的角度而言，也可以将非终结符视为递归的场景，而终结符当作是停止递归的场景。产生式也被称为*产生规则*或者*规则*， 尽管它们通常可以互换而不会引起混淆，但是我们将在本报告中保持一致，仅使用第一个术语，因为规则的含义略有不同。

为了将一组指令建模为上下文无关语法，给每条指令添加一条或多条规则。我们称这个规则集合为*指令集语法*。每条规则包含了一个产生式，开销，和一个动作。产生式的右侧表示要在表达式树上匹配的树模式，左侧包含的非终结符，用来表示执行机器指令的结果的特征（如一个特定的寄存器类型）。此处的开销就含义明了的，而动作通常是输出一个汇编字符串。我们用一个带注释的示例更简洁地说明规则的结构：

{% if 1 == 1 %} 
  {% asset_img s_3_2.png title %}
{% else %}
![](H:\Blogs\fiking\source\_posts\指令选择的调查\s_3_2.png)

{% endif %}

在大多数的文献中，*规则*和*模式*通常是有相同含义的。但是，在这篇报告中，处于语法上下文的一条规则是一个包含产生式，开销，和动作的三元组，而一个模式指的是出现在规则中的产生式的右侧内容。

*树解析*

指令集语法给我们提供了一个形式化建模机器指令的方法，但是它没有解决模式匹配和模式选择的问题。对于这个问题，Glanville 和 Graham 应用了一个已知的技术，*LR parsing*（左到右，最右边归约）。因为这个技术主要与语法解析相关，所以应用到树上的相同方法通常称为*树解析*。我们继续举一个例子。

让我们假设我们有下面的指令集语法

{% if 1 == 1 %} 
  {% asset_img s_3_3.png title %}
{% else %}
![](H:\Blogs\fiking\source\_posts\指令选择的调查\s_3_3.png)

{% endif %}

然后我们想要产生如下表达式树的汇编代码
$$
+\ c\ *\ a\ b
$$
使得表达式的结果最终在寄存器中。如果 a，b，和 c 都是整形，则我们可以假设表达式树上的每个节点都是 Int 类型，*，或者 +；这些将会是我们的终结符。

在将表达式树转换为终结符序列后，我们从左到右依次遍历每一个。在这个过程中，我们要么将刚刚遍历到的符号放到栈上，或者通过一个*规则归约*替换当前栈上的符号。一个*归约*操作有两部分组成：首先根据出现在规则右侧的内容弹出符号。数量和顺序必须与一条有效的归约规则匹配。弹出后，出现在左侧的非终结符将被压入到栈上，同时也会输出与规则相关联的汇编代码（如果有）。对于一个给定的输入，执行规则归约也可以被表示成一个*解析树*，演示了用于解析这颗树的终结符和非终结符。现在，回到我们的用例，如果我们用 s 表示一个*转换*，以及用 $r_x$ 表示一个*归约*，其中 x 是归约规则的数量，则表达式树 ”+ Int(c) * Int(a) Int(b)“ 的一个有效树解析是：
$$
S\ S\ S\ r_3\ r_2\ S\ r_3\ r_1
$$
证明这个式子作为一个习题留给读者解决。对于这个特定的树解析，相关的解析树和产生的相关汇编代码如下：

{% if 1 == 1 %} 
  {% asset_img s_3_4.png title %}
{% else %}
![](H:\Blogs\fiking\source\_posts\指令选择的调查\s_3_4.png)

{% endif %}

剩下的问题是如何知道何时*转换*以及何时*归约*。这个可以通过查阅特定语法生成的*状态表*来。这个表是如何生成的已经超出了本报告的范围，但是会在图 3.4 中给出一个例子，它是由图 3.3 中的指令集语法生成的。然后图 3.5 给出了一个使用这个状态表执行指令选择器的过程。图 3.3 中的一些产生式里出现的下标是语义限定词，它用于表达可能会出现在机器指令中的语法限制。例如，所有的双地址算术机器指令都将结果存储到作为输入提供的寄存器中的一个，然后使用语法限定词它可以表达为 $r_1 \rightarrow + r_1\ r_2$，表明目的寄存器必须与第一个操作数相同。为了让这个信息在解析期间是有效的，解析器将其与它相关联的终结符或非终结符符号一起放到栈上。Glaville 和 Graham 也整合了一个寄存器分配器到他们的解析器中，因此，给出了整个代码生成的后端。

*解决冲突和避免阻塞*

一个指令集语法通常是由二义性的，意味着相同的表达式树可能会存在多个有效的树解析，这会导致解析器可能会存在一个可以执行移位也可以执行归约的情况。这被称为移位归约冲突，是一个非正交的 ISA 会出现的结果。为了解决这种冲突，Glaville 和 Graham 的状态表生成器总是选择移位。直观上，这会有利于较大的模式而不是较小的模式，因为一个移位推迟了模式选择的决策，同时允许有关表达式树的更多信息堆积到栈上。

同样地，也可能存在一个归约归约冲突，即解析器在一个归约选择规则的时候存在两个或多个选择。Glaville 和 Graham 通过选择有最长右侧的规则来解决这个问题。如果语法包含的规则仅在它们的语法限定词上不同，则仍然存在超过一条规则可以归约（在图 3.3 中，规则 5 和 6 就是两条这样的规则）。解析期间里可以解决这个问题，方法是在这个期间里按它们出现在语法中的顺序检查语法限制（例如，参考图 3.4 中的状态 ）。但是，如果这个集合中的所有规则都是有语法限制的，则会出现解析器无法选择任意一条规则的情况。这种情况称为语义阻塞，必须要提供一条默认的规则才能解决这个问题，这条规则会在除它以外的所有情况都失败的情况下被调用。这种回退规则通常使用多个，较短的机器指令来模拟比较复杂的规则的效果，然后 Glanville 和 Graham 设计了一个精妙的技巧来自动推导它们：对于每个语义约束规则，树解析是在表示该规则右侧的表达式树上进行的，然后使用为实现该树而选择的机器指令来构成回退规则。

{% if 1 == 1 %} 
  {% asset_img figure_3_3.png title %}
{% else %}
![](H:\Blogs\fiking\source\_posts\指令选择的调查\figure_3_3.png)

{% endif %}

{% if 1 == 1 %} 
  {% asset_img figure_3_5.png title %}
{% else %}
![](H:\Blogs\fiking\source\_posts\指令选择的调查\figure_3_5.png)

{% endif %}

*优势*

通过依赖状态表，Glanville-Graham 形式的指令选择器是完全表驱动的，由基本上是一系列表查找组成的核心实现。故而，指令选择器产生汇编代码需要花费的时间是线性于表达式树的大小的。尽管表驱动代码生成的想法并不新颖 -- 我们在之前的章节中已经见过一些了 -- 但是早期的尝试为产生表提供一个自动化的过程都失败了。此外，许多与模式选择相关 的决策都是在状态表生成时解决移位-归约冲突和归约-归约冲突来预先计算的，这会使得编译更快。

Glanville-Graham 方法的另一个优势是它的形式化基础使得自动化验证的方式成为可能。例如，Emmelmann [80] 提出了证明指令集语法完整性的方法，这个方法是第一批验证方法中的一个。直观上，Emmelmann 自动化证明法是寻找所有的可以出现在输入程序但不能被指令选择器处理的表达式树。让我们将指令集语法表示为 $G$，描述表达式树的语法表示为$\tau$。如果我们进一步用 $L(x)$ 来表示所有能被语法 $x$ 接受的树的集合，则我们可以通过检查 $L(\tau)/L(G)$ 是否生成非空集来确定指令集语法是否完整。Emmelmann 认识到这个交叉可以通过创建一个*生成自动机*来计算，这个自动机本质上是实现了只接受这组反例中的树的语言。Brandner [34] 最近扩展了这个方法来处理包含称为*谓词*的动态检查的产生式 -- 我们将在探索属性语法时简短地讨论 - 通过拆分终结符来暴露这些隐藏的特性。

*劣势*

虽然 Glanville-Graham 方法解决了几个当前的指令选择技术的问题，但是它也有自己的劣势。首先，由于解析器只能对语法进行推理，因此关于特定值或者范围的任何限制都必须赋予它自己的非终结符。与限制结合则每个产生式就可以只匹配到单个的树模式，这通常意味着，对于带有几个地址或者操作数模式的多功能机器指令的规则对于每个这样的结合都要重复一份。但是，对于大部分的目标机器，这被证明时不可行的；在 VAX 机器的场景中 -- 基于 CISC 的架构开始于 1980 年代，每条机器指令都接受多个操作数模式 [48] -- 因此一个指令集语法将会包含超过八百万条规则[127]。重构 -- 通过非终结符表达共享特征来合并相似规则的任务 -- 会将这个数量降低到大约只有千条规则左右，但是这个不得不做得非常小心，从而避免对代码质量有负面的影响。第二，因为解析器从左往右遍历没有回溯，所以必须在其它任意操作数可以观察到前，先输出一个操作数的汇编代码。这会导致一个比较坏的决策，在之后会取消然后输出另外的代码。因此，设计一个紧凑的指令集语法 -- 其也会产生好的代码质量 -- 语法作者必须对指令选择器的内部工作有广泛的了解。

#### 使用语义处理扩展语法

在纯的上下文无关语法中，是完全无法处理语义信息的。例如，用 reg 非终结符表示一个明确的寄存器是做不到的。Glanville 和 Graham 通过将信息放到栈上来解决这个限制，但即使这样，他们修改后的 LR 解析器也只能使用简单的等式比较进行推理。Ganapathi 和 Fischer [112, 113, 114, 115] 通过将传统的上下文无关语法替换为更强大的语法集即属性语法，来解决这个问题。就像 Glanville-Graham 方法，我们将只会在顶层讨论它是如何工作的；对细节感兴趣的读者建议去进一步了解相关的论文。

*属性语法*

属性语法 -- 或者他们也称为*词缀语法* -- 是 Knuth 在 1968 年引入的，他将上下文无关语法扩展成带有属性的。属性用于存储，操纵，以及在解析期间传播关于独立的终结符和非终结符的额外信息，然后一个属性要么是合成的要么是继承的。使用解析树作为参考点，带有同步属性形式的节点的值来自于它的子节点的属性，带有继承属性的节点的值拷贝自子节点的值。因此，合成属性的信息沿着树向上流动，而继承属性的信息沿着树向下流动。故我们通过 $\uparrow$ 和 $\downarrow$ 分别区分合成属性和继承属性， 这两个会标注为特定符号的前缀（如，一个 reg 非终结符的 x 合成属性写为 reg $\uparrow$ x）。

然后这个属性用在谓词和动作里。谓词用于检查一个规则的适用性，动作用于产生新的合成属性。因此，当建模机器指令的时候，我们使用可以谓词来表示约束，使用动作来表明效果，如代码输出和结果会被存储到什么寄存器里。让我们看个例子。

在图 3.6 中，我们看到一组建模三个字节加法机器指令的规则：一个增量版本 incb（将寄存器递增 1，由规则 1 和 2 建模）；一个两地址的版本 add2b（加两个寄存器和存储结果到其中一个操作数中，由规则 3 和 4 建模）；一个三地址版本 add3b（结果可以存储到其它地方，由规则 5 建模）。自然地，incb 指令只能被用到其中一个操作数是 1 的场景下，这个值是通过谓词 *IsOne* 强制限制的。此外，因此这条指令破坏了这个寄存器的前一个值，只有后续的指令不会在使用到这个旧值，才可以使用这条指令；这被谓词 *NotBusy* 强制执行。然后 EMIT 动作输出相关的汇编代码。因为加法是可交换的，我们需要两条规则来使得机器指令适用于这两种情况。类似地，我们在 add2b 指令上也有两条规则，但是谓词被替换成了*TwoOp*，它会检查是否其中一个操作数是赋值目标，或者这个是否后续不需要了（即，它不忙了）。 因为，最后一条规则没有任何的谓词限制，所以它也作为默认规则，从而防止出现我们之前讨论的在覆盖 Glanville-Graham 方法时出现的语义阻塞的情况。

{% if 1 == 1 %} 
  {% asset_img figure_3_6.png title %}
{% else %}
![](H:\Blogs\fiking\source\_posts\指令选择的调查\figure_3_6.png)

{% endif %}

*优缺点*

使用谓词就不需要在为了表达特定的值和范围而引入新的非终结符，这使得指令集语法更加简明。在 VAX 机器的场景中，属性的使用导致了语法大小只有 Glanville-Graham 方法需要的一半，并且没有大量的重构[113]。属性语法也促进了机器描述的增量开发：它可以从实现最通用的规则开始，以实现生成正确但效率低下的代码的指令集语法。然后处理更复杂的机器指令的规则可以增量地添加，因此可以平衡实现工作量和代码质量。另一个很好的特性是其它的优化例程，如常量折叠，可以表示为语法的一部分，而不是单独的组件。

但是，为了允许属性和 LR 解析器一起使用，必须限制指令集语法的属性。首先，只有合成属性可以出现在非终结符中。这是因为 LR 解析器是自底向上，从左往右的构造解析树的，从叶子开始，向上延伸到根部。因此，用于指导子树构建的继承值只有在子树已经创建之后才可用。第二，因为谓词可能会使得一条规则对规则归约无效，所以所有的动作必须出现在产生式的最右侧；否则，可能会导致无法取消的不正确效果。第三，与 Glanville-Graham 方法一样，解析器必须对一个子树做出决定，而不考虑可能出现在右侧的兄弟子树。因此，如果所有的子树事先都是有效的，则它可以提高汇编代码的质量，这是由于使用了 LR 解析的又一个限制。后来 Ganapathi [111] 做了一个解决这个问题的尝试，使用 Prolog 来实现指令选择器 -- Prolog 是一个逻辑编程语言 -- 但这导致了指数级的最坏运行时间。

#### 维护多个解析树而获得更好的代码质量

因为 LR 解析器只对表达式树进行了一次遍历 -- 因此只产生了许多可能的解析树中的一个 -- 产生的汇编代码严重地依赖于指令集语法来指导解析器寻找到 “好的” 解析树。

Christopher 等人[52] 尝试解决这个问题，通过使用 Glanville-Graham 方法的概念，但是扩展了解析器以生成所有的解析树，然后选择能生成最好汇编代码的那个。这是通过将原来的 LR（1）解析器替换为 Earley 的算法 [74] 来达成的，虽然这个方法某种程度上提高了代码质量 -- 至少理论上 -- 但它是以枚举出所有解析树为代价的，这在实际中是非常昂贵的。

在 2000 年，Madhavan 等人[181] 扩展了 Glanville-Graham 方法来获得一个最优的模式选择，同时据称保留了 LR 解析的线性时间复杂度。通过引入一个新版本的 LR 解析[230]，之前在找到一条匹配规则会直接执行的归约，现在允许推迟任意的步数。因此，指令选择器本质上还是追踪了多个解析树，允许它在做出可能证明是次优决定之前，可以收集足够多的关于输入程序的信息。换句话说，类似于 Christopher 等人的，Madhavan 等人的设计也会覆盖所有的解析树，但会立即丢弃掉被确实是产生低效汇编代码的解析树。为了有效地做到这点，该方法还引入了离线开销分析，我们将在后面的 3.6.3 节中讨论到这个。最近，Yang [266] 提出了一个相似的技术，涉及到*解析树仙人掌*[sic]的使用，其中偏离的解析树从公共主干分支出来，从而减少了需要的空间。但是，两种的基本原则仍然禁止建模许多典型的目标机器特性，如多输出指令。

### 使用递归自顶向下覆盖树

到目前为止检查过的树覆盖方法 -- 特别是那些基于 LR 解析的 -- 都是自底向上操作的：指令选择器从覆盖表达式树的叶子节点开始，然后基于这些决策，它随后覆盖了剩余的子树直到它到达根，沿途不断匹配和选择适用的模式。这绝不是唯一的覆盖方法，因为它也可以自上而下地完成。有这样一种方法，指令选择器从根节点开始覆盖表达式树，然后递归向下进行匹配。最后，语义信息的流动（如，会存储结果的特定寄存器）也是不同的：自底向上的指令选择器让这些信息沿着表达式树向上扩散 -- 通过辅助的数据结构或者树重写 -- 而自顶向下的实现会实现决定这个并向下推进。因此，后者被认为是目标驱动的，因为模式选择是由一组额外的需求引导的，而这些需求必须由所选的模式满足。因为，这反过来会对子树产生新的需求，所以大部分的自顶向下的技术都是使用带有回溯的递归实现的。这是必须的，因为某些模式的选择可能会导致低级别的表达式树变得无法被覆盖。

{% if 1 == 1 %} 
  {% asset_img s_3_5.png title %}
{% else %}
![](H:\Blogs\fiking\source\_posts\指令选择的调查\s_3_5.png)

{% endif %}

#### 第一个方法

*手段-目的分析指导指令选择*

据我所知，Newcomer[194] 是第一个开发了使用自顶向下覆盖的方法来解决指令选择问题的人。在他 1975 的博士论文中，Newcomer 提出了一个设计，能详细地找出所有覆盖给定表达式树的模式的组合，然后选出一个最小开销的。Cattell[45] 也在他的调查文章中描述了这些，这是本次讨论的主要来源。

机器指令被建模成*T-operators*，其基本上是附带了成本和属性的树模式。这个属性描述了各种限制，如哪个寄存器可以用于操作数上。也有一组指令选择器用于执行输入程序必要的转换的 T-operators -- 随着我们的进一步讨论这个需求会变得清晰。使用这个工具集，该方案将 AST 作为期望的输入，然后按之前说的自顶向下的方法转换它：指令选择器尝试为 AST 的根节点找到所有匹配的模式，然后进一步递归地覆盖每个匹配剩余的子树。模式匹配是使用我们以前知道的一种直接技术完成的（见 25 页图 3.2），然后为了高效，所有的模式都根据它们的根节点类型进行标注。因此，这个过程的结果是一组模式序列，其中每个都覆盖了整个 AST。然后，检查每个序列是否每个模式的属性都是等于*首选属性集*（PAS），其因此对应于目标。否则，指令选择器将尝试使用 T-operators 转换重写子树直到属性匹配上。为了指导这个过程，Newcomer 应用了一个启发式规则称为*手段目的分析*，它是 Newell 和 Simon [195] 在 1959 年介绍的。 手段-目的分析背后直观上是递归地最小化数量差异 -- 如何计算的没有在 [45] 中提到 -- 在当前状态（即，子树现在的样子）和目标状态（它应该成为的样子）之间的。为了避免无限循环，当转换过程到达搜索空间中的特定深度，它就会停止。如果成功，则应用的转化会被插入到模式序列中；否则丢弃掉序列。从被找到的模式序列中，选出总开销最低的，随后是代码输出。

作为手段-目的分析的应用，Newcomer 的方法是开创性的，让它可以指导输入程序的修改过程直到它可以在特定目标机器上实现，而不需要特地采用特定目标机制。但是，这个设计并非没有缺陷的。首先，这个设计几乎没有实际的应用，因为它只能处理算术表达式。第二，用于建模机器指令的 T-operators 和转换相同，也不得不手动构造，这是非平凡的，阻碍了编译器的可移植性。第三，由于搜索空间的截断，转换输入程序的过程可能会过早地结束，导致指令选择器无法生成任何的汇编代码。最后，事实证明除了最小的输入树外，搜索策略的代价太高因而无法在实践中使用它。

*让手段-目标分析在实际中可用*

Cattel 等人[44，47，176]后来提高和扩展了 Newcomer 的工作，使之成为一个更实用的框架，被实现在产生质量编译器-编译器（PQCC）中，Bliss-11 编译器的衍生版本，最初是由 Wulf 等人实现的 [264]。他们的方法不是在编译输入程序的时候执行手段-目的分析，而是在生成编译器本身的时候将其作为预处理步骤 -- 更类似于 Glanville-Graham 方法。

模式由一组模板表示，这些模板使用递归组合形成，因此类似于指令集语法中的产生式。但是不像 Glanville 和 Graham 以及 Granapathi 和 Fischer 的设计，模板不是手写的，而是根据特定的机器描述自动生成的。每个机器指令描述为一组机器操作，其描述了指令的效果，因此类似于前一章中的 Fraser [102] 介绍的 RTLs。 然后这些效果被一个称为 CGG（代码生成器的生成器）的分离工具用于创建模板，而模板被指令选择器所使用。为了产生与机器指令直接对应的平凡模板，CGG 也会产生一组单节点模式和一组结合了多个机器指令的巨大模式。前者保证了指令选择器可以为所有的输入程序生成汇编代码，因为任意的表达式树都可以简单的被覆盖；而后者可以降低编译时间，因为比起多个小的匹配，直接匹配一个大的模式更快。为了实现这个，CGG 组合使用了手段-目的分析和启发式规则，其应用了一组公式（如，$\neg\neg E\Leftrightarrow E,\ E+0\Leftrightarrow E,\ \neg(E_1 \ge E_2) \Leftrightarrow E_1\lt E_2$）来操作和合并存在的树模式。但是，不保证“感兴趣”的树模式都是永远适用的。一旦生成，则指令选择器就会以贪婪的，自顶向下的方式执行，它总是选择与表达式树中的当前节点相匹配的最小开销的模板（模板匹配使用的方法与 Newcomer 的方法完全相同）。如果出现平局，则指令选择器会选择内存加载次数最少的模板。

与之前讨论的基于 LR-解析的方法相比，Cattell 等人的方法也由优缺点。主要的优点是无论提供了模板是什么，产生的指令选择器总是能够为所有可能的输入树生成有效的汇编代码。至少在 Granapathi 和 Fischer 的设计中，语法设计者必须保证这个正确性。缺点是它的速度相当的慢：基于树解析的指令选择器在模式匹配和模式选择两个方面都是线性时间复杂度的，而 Cattell 等人的指令选择器不得不单独的匹配每个模板，在最坏时间复杂度下是需要2次方的时间。

*最近的技术*

据我所知，最近唯一使用这种递归自顶向下的方法进行树覆盖的方案是 Nymeyer 等人的[197, 198]。在 1996 和 1997 两篇文章中，Nymeyer 等人描述了一个方法，A* 搜索 -- 另一个控制搜索空间的策略（见[219]）-- 和自底向上重写系统理论相结合的方法，或者简称为 BURS。我们将会在本章的后续内容中详细地讨论 BURS 理论 -- 着急的读者可以直接跳到 3.6.3 节中 -- 当下只要提到基于 BURS 的语法允许的转换规则就足够了，如会包含将 $X\ +\ Y$ 重写为 $Y\ +\ X$ 的规则，这可能会简化和减少表达机器指令需要的规则数。但是，作者没有给出任何的实验数据，从而难以判断 A*-BURS 理论的组合是否是在实际中可以应用的技术。

### 树重写和树覆盖的说明

在这个时候，有些读者可能会觉得树重写 -- 其中模式被迭代地选择以重写表达式树，直到它由某个目标类型的单个节点组成 -- 与树覆盖是完全不同的 -- 其中合适的节点会被选出来覆盖表达式树中的所有节点。事实它们确实存在着些许不同，但是对于使用树重写表达的问题是有效的方法，对于等价的用树覆盖表达的问题也是有效的，反之亦然。因此可以认为两者是可以互换的。但是我认为树重写是解决树覆盖问题的一种方案，而树覆盖才是基本的原则问题。

### 分离的模式匹配和模式选择

## DAG 覆盖

就像我们在前一章节见到的，树匹配的原理带有一些缺点：无法合适地表达公用子表达式，且无法建模许多机器特性如多输出指令。因为这些限制是由于完全依赖树结构导致的，我们可以通过将树覆盖扩展到 DAG 覆盖来放开它们。

### 原理

如果我们移除树中的每对节点都必须只能有一条路径，我们会获得一个新的图形称为*有向无环图*，通常称为 DAGs。则现在的节点允许有多个输出边，因此表达式的中间值可以在相同的图里共享和重复使用，也会包含多个根节点。为了区分表达式的树建模和 DAG 建模，我们称后者为 *表达式* DAGs。一旦能构成这种形式后，指令选择的过程就可以应用我们从前一章学到的模式匹配和模式选择的相同原则来处理。当模式允许多个根节点，我们可以建模和利用大的机器指令集，例如多输出的指令，像 divmod 其可以同时计算商和余数。

{% if 1 == 1 %} 
  {% asset_img s_4_1.png title %}
{% else %}
![](H:\Blogs\fiking\source\_posts\指令选择的调查\s_4_1.png)

{% endif %}

### DAGs 上的最优模式选择是 NP 完全问题

不幸地是，DAGs 给我们的这种普遍性收益和建模能力的成本是复杂性的的大幅提升。在树上选择一个最优的模式集是可以在线性时间里完成的，但在 DAGs 做相同的事情确是一个 NP 完全的问题。Bruno 、 Sethi [38] 和 Aho 等人[4] 在 1976 年已经证明了这个问题，虽然两者都更关心指令调度和寄存器分配的最优性。在 1995 年，Proebsting [206] 给出了最优指令选择的简洁证明，后来在 2008 年 Koes 和 Goldstein [161] 重新形式化了它。我们会在本文中描述 Koes 和 Goldstein 的证明。请注意完成这个是不需要涉及模式匹配任务的 -- 就像我们会看到的，如果模式由树组成，则可以在多项式的时间里完成这个。

#### 证明

这个思路是将 SAT（布尔可满足性）问题精简为一个最优（即，最低开销）DAG 覆盖问题。SAT 问题用来判断一个*合取范式*（CNF）中的布尔公式是否可以被满足。一个 CNF 表达式是如下形式的公式
$$
(x_{11}\vee x_{12} \vee ...) \wedge (x_{21} \vee x_{22} \vee ...) \wedge ...
$$
变量 $x$ 可以通过 $\neg x$ 取反。因为这个问题已经被证明是 NP-完全的了[62]，所有 SAT 可以多项式时间归约成的问题$\chi$，都会使得 $\chi$ 是 NP-完全的。

*将 SAT 建模为覆盖问题*

首先我们将一个 SAT 问题实例 $S$ 转换为 DAG。直观上，如果我们可以用单元开销的模式覆盖 DAG，则总开销等于节点的数量（假设每个变量和操作都产生一个新节点），那么存在对变量的真值赋值式，公式对其求值为 $T$。因为这个目的，DAG 中的节点可以是 $\{ \vee, \wedge,\neg,v, \square, \diamond \}$ 类型。我们定义 $type(n)$ 作为节点 $n$ 的类型。分别称 $\Box$ 类型的节点和 $\diamond$ 类型的节点为*box 节点* 和*stop 节点*。我们也定义了$children(n)$ 作为 $n$ 的子节点集。对于每个布尔变量 $x \in S$ ，我们创建两个节点 $n_1$ 和 $n_2$，则 $type(n_1) = v$ ，$type(n_2) = \square$，且有一条直连边 $n_1 \rightarrow n_2$。我们对每个二元布尔操作符 $op \in S$ 都做相同的操作，创建两个节点 $n_{1}^{'}$ 和 $n_{2}^{'}$，则 $type(n_{1}^{'}) = op$ ，$type(n_{2}^{'}) = \square$，且有一条直连边 $n_{1}^{'} \rightarrow n_{2}^{'}$。我们通过操作数的箱子节点，将操作符与它的输入操作数 $x$ 和 $y$ 连接在一起，即两条边 $n_x \rightarrow n_{1}^{'}$ 和 $n_y \rightarrow n_{1}^{'}$ 其中$type(n_x) = type(n_y) = \Box$。对于一元操作 $\neg$， 我们显然只需要一条这样的边，并且因为布尔 *or* 和 *and* 是可交换的，所以边排布的顺序与相关操作符节点的顺序是无关紧要的。最后，只有 box 节点会多于一条输出边。

通过简单地遍历布尔公式，我们可以在线性时间里构造 DAG。图 4.1（b）给出了一个 SAT 问题转换为 DAG 覆盖问题的例子。

*布尔操作作为模式*

然后我们构造一组树模式 $P_{SAT}$， 它允许我们去推断如何设置 *S* 中的变量，从而可以满足表达式（见图 4.1（a））。如果值假定被设置为 $T$（true），则模式的形成会有一个 box 节点作为叶子。而且，如果操作的结果判定为 *F*（false），则模式会有一个 box 节点作为根。确定它的一个方式是，如果模式中的一个操作符*消费*一个 box 节点，则值必须设置为*T*；然后如果操作符*产生*了一个 box 节点，则结果必须设定为*F*。为了强制整个表达式求值为*T*，唯一个包含 stop 节点（即，$\diamond$ 类型）的模式也消费了一个 box 节点。

{% if 1 == 1 %} 
  {% asset_img s_4_2.png title %}
{% else %}
![](H:\Blogs\fiking\source\_posts\指令选择的调查\s_4_2.png)

{% endif %}

除了节点类型可以出现在表达式 DAG 中，模式也会使用额外的类型节点，我们称它为*锚节点*。现在，我们认为一个带有根 $p_r$ 的树模式匹配了一个节点$v\in V$，其中 *V* 是表达式 DAG $D = (V, E)$ 中的节点集，当且仅当：

1. $type(v) = type(p_r)$,
2. $|children(v)| = |children(p_r)|$，且
3. $\forall c_v \in children(v), c_r \in children(p_r) : (type(c_r) = \bullet) \vee (c_r 匹配 c_v)$。

换句话说，除了可以在任意节点匹配的锚节点外，树模式的结构必须对应于已匹配的子图结构。我们也采用了两个新的定义：$matchset(v)$，它是 $P_{SAT}$ 中匹配 $v$ 的模式集合；还有$m_{p_i \rightarrow v}(v_p)$，它是 DAG 节点$v \in V$，对应于已匹配模式 $p_i$ 中的模式节点 $v_p$ 。最后，我们说一个 DAG $D = (V, E)$ 可以被映射函数$f : V \rightarrow 2^T$ 从 DAG 节点到模式*覆盖*，当且仅当$\forall v \in V$：

1. $p \in f(v) \Rightarrow p$ 匹配 $v$ 且 $p \in P_{SAT}$，
2. $in-degree(v) = 0 \Rightarrow |f(v)| > 0$，且
3. $\forall p \in f(v)$，$\forall v_p \in  p$ **s.t.** $type(v_p) = \bullet \Rightarrow |f(m_{p_i -\rightarrow v}(v_p))| > 0$。

第一个约束强制每个选定的模式都匹配了且都是实际的模式。第二个约束强制了停止节点的匹配，且第三个约束强制了剩余 DAG 的匹配。因此，$D = (V，E)$ 的一个最优覆盖是覆盖 $D$ 的映射 $f$，和最小的
$$
\sum_{v\in V} \sum_{p \in f(v)} cost(p)
$$
其中 $cost(t)$ 是模式 $p$ 的开销。

*DAG 覆盖的最优方案 $\Rightarrow$ SAT 的方案*

现在我们假定，如果这个最优覆盖的总开销等于 DAG 中非盒子节点的数量，则对应的 SAT 问题就成立了。因为 $P_{SAT}$ 中的所有模式恰好只覆盖一个非盒节点，且有相等的单元开销，然后如果 DAG 中每个非盒节点仅被一个模式覆盖，所以只需查看选择了哪个模式来覆盖变量节点，我们就可以简单地推断出布尔变量的真值分配。

因此，我们证明了一个 SAT 问题实例可以在多项式时间里归约成一个最优 DAG 覆盖问题实例，从而得到解决。故而，最优的 DAG 覆盖 -- 也就是基于 DAG 覆盖的最优指令选择 -- 是 NP-完全的。

### 树模式覆盖 DAG

Aho 等人的[4] 是第一篇提供在 DAGs 操作的代码生成方法的文章。在他们发表于 1976 年的文章中，Aho 等人提出了一些简单的，贪心的启发式，以及一个最优的代码生成器，其为一个可交换的单寄存器机器生成代码。但是，他们的方法假定了表达式节点到机器指令是一对一映射的，所以有效地规避了指令选择的问题。

因为最优模式选择的 DAG 指令选择在计算上是复杂的，所以第一个基于这个原理的第一个合适的方法，使用了 DAGs 来建模输入程序的表达式，但仍将模式作为树。通过这个，则开发者可以采用来自树覆盖的已知的，线性时间的方法，并将它们扩展到 DAG 覆盖。然后根据上一章我们讨论的方法，通过解决掉公共子表达式，我们可以将表达式 DAGs 转为树。我们称这个为*解DAG*

### 解表达式 DAG  为树

有两种方法可以将表达式 DAG 解DAG 为树。第一种方法是拆分共享节点的边（即，重用发生的地方），产生一组不相连接的表达式树，这些表达式树可以独立地使用通用树覆盖技术进行覆盖。通过强制将根节点在前一个共享节点的表达式树的结果写到一个特殊的位置（通常是主存），维护树之间的隐式连接。然后它们可以被其它的表达式树使用，故需要增强这些表达式树来反映这个新的输入源。使用这个方法的一个实现例子是 DAGON，它是 Keutzer[156] 开发的一个技术粘合器，将技术独立的描述映射到电路。第二个方法是在节点重用出现的地方复制一下节点， 这也可能会产生许多的树。两个概念都在图 4.2 中标明了。

{% if 1 == 1 %} 
  {% asset_img s_4_3.png title %}
{% else %}
![](H:\Blogs\fiking\source\_posts\指令选择的调查\s_4_3.png)

{% endif %}

尽管解 DAG技术允许在 DAG 上使用基于树覆盖的技术来完成指令选择，但它是以牺牲性能为代价的：过于激进的边拆分阻碍了大模式的应用，因为它产生了许多小的树；同时太激进的节点复制会导致低效的汇编代码，因为有许多的操作在最后的程序中是不需要重复执行的。而且，拆分的 DAG 的中间结果必须被强制存储，这对于异构内存寄存器架构来说是比较麻烦的。Araujo 等人验证了最后一个问题 [17]。

*拆分和复制的平衡*

Fauth 等人[92，191] 在 1994 年提出了通过平衡节点复制和边拆分，尝试改善解 DAG 的不足。实现在了 CBC （通用总线编译器）中，它的指令选择器应用了一个倾向于复制直到开销被认为太高，这个算法才变为拆分的启发式规则。复制还是拆分的决定是通过比较两个解决方法的代价来确定的，会选择最廉价的那一个。

## 基于图的方法

即使是我们上一章研究的 DAG 覆盖，比起树覆盖有更通用和更强大的形式，它仍然不足以处输入程序和机器指令的所有方面。例如，for 循环语句导致的控制流无法建模成表达式的一部分，因为它需要循环，这违背了 DAGs 的定义。通过移除这个限制，我们最终得到最通用的形式，即图覆盖。

### 原理

### 使用子图同构的模式匹配

### 基于图的模式选择技术

#### 一元和二元覆盖

#### 基于 CP 的技术

#### 基于 PBQP 的技术

### 基于处理器建模的方法

在前一章中，我们看到了一种微代码生成的方法，其建模了目标处理器的整个数据链路，而不仅仅只是可用的指令集。这里我们将会关注依赖于相同建模方案但解决了指令选择更传统的问题的技术。

#### CHESS

在 1990 年，Lanneer 等人[166] 开发了一个方案，其在后来被 Van Praet 等人[249, 250]用在了他们实现的 CHESS 上，这是一个知名的针对 DSPs 和 ASIPs 的编译器，是一个欧洲项目的成果。

将 CHESS 和 MSSQ 比较时 --  MSSQ 我们在 4.3.5 节中解读过了-- 有两个显著的不同。首先，在 MSSQ 中处理器的数据链路是由手工写的描述文件提供的，而 CHESS 中数据链路是由基于 nML 格式的文件自动生成的[90，91]，这减少了人力需求。

 第二，打包的方法 -- 即合并能并行执行的操作 -- 是不同的：在 MSSQ 中，指令选择器依赖于 DAG 覆盖，通过寻找数据路径模型图中的子图来覆盖表达式树，然后在模式选择之后，一个后续的例程尝试调度选择好的指令使其并行化。与之相反的是， CHESS 采用了更渐进的方式，制定了一个*链接图*，其中每个节点表示表达式图中的一个操作（允许包含循环）。节点由可以执行这个操作的功能单元标注着。在 DSP 处理器上，功能单元通常被分组为功能构建块（FBBs），然后为每对潜在的能在相同的 FBB 中执行的节点对在链接图中添加一条边（这被称为链接）。在然后一个启发式的算法尝试去收缩链接图中的节点，通过选择一条边，接着用一个新节点替换两个节点，然后删除不能在再与新节点的操作在同一个 FBB 上执行的边。这个过程会一直迭代直到没有节点能在压缩的，然后链接图中剩余的每个节点都构成一个包。后来这个作者在 [249] 中扩展了这个方法，通过分支限界搜索在所有可能的包中进行选择，允许表达式图中相同的操作出现在多个包中。

通过链接图逐步构建包的方式，Van Praet 等人的方法能够将整个函数建模为表达式图和跨基本块边界的包操作。它的集成特性也允许为复杂的架构生成汇编代码，让它适合于 DSPs 和 ASIPs 等这类数据路径通常是非常的规律的结构，因为它是基于图的，所以它似乎可以扩展到建模具有内部循环的机器指令。但是，尚不清楚这种方式如何处理相互依赖的机器指令。

#### 模拟退火

另一个尽管不是很常见的技术是由 Visser [251] 提出的。就像 MSSQ 和 CHESS 一样，Visser 的设计是一种集成的代码生成技术，但是应用了模拟退火理论来提高效果。 

